# Merge e Rebase

No módulo passado você aprendeu a criar branchs e a trabalhar com eles. Viu a importância dos mesmos.

### Merge

Agora vamos mostrar como fazer para mesclar os branchs para que as funcionalidades se somem em um mesmo branch. O comando para fazer esta mesclagem se chama **merge**.

Nós temos o branch funcionalidade1 e o branch master, em nosso exemplo.

Existem dois tipos de merge um mais simples e outro um pouco mais complexo. O mais simples é quando criamos um branch e fazemos alteração apenas no branch. Imagina que tivessemos criado a funcionalidade e no branch master não tivessemos feito mais nada e não ter dado nenhum commit. Esta é a situação mais simples e o branch mais fácil que existe.

Mas não foi o que aconteceu em nosso exemplo. Lembre-se que, no módulo anterior, além de criar um arquivo no branch funcionalidade1, nós pedimos que alterasse um arquivo no branch master. Então temos alterações, e commits, nos dois branchs.

Isso significa que o branch funcionalidade1 não possui um dos commits que o master possui. Então acesse o branch master e rode o comando abaixo:

`$ git merge funcionalidade1`

Este comando se comporta como um commit e abre um editor para que adicionemos uma mensagem de identificação. Depois de rodar este arquivo teremos, tanto os commits existentes no branch funcionalidade1, quanto os arquivos que lá foram criados.

Poderíamos ter feito o inverso também, de dentro do branch funcionalidade1 rodar um merge no branch master.

Existe uma forma de gerar um merge sem que ele gere um commit, porque nem sempre é legal gerar um commit novo a cada merge, no projeto. Mas este comando só pode ser rodado localmente, para que não gere confusão para outros usuários do repositório.

### Rebase

Para exemplificar o rebase vamos remover o último commit relacionado ao merge.

`$ git reset HEAD~1 --hard`

Agora que voltamos o último commit, temos o mesmo cenário, do início, do módulo anterior.

Lembrando a ordem que fizemos a alteração podemos dizer que temos primeiro um commit no branch funcionalidade1 e depois um branch no master. Porque logo que criamos o branch funcionalidade1 nós já criamos o arquivo e já fizemos o commit, depois fomos para o master, alteramos um arquivo e fizemos o commit.

Por que estamos falando de ordem? Porque o rebase fará a mesma coisa que um merge, mas levando em consideração a ordem dos commits. Por este motivo que ele deve ser feito somente em sua máquina, porque ele estará fazendo o merge na sequencia correta. Isso quer dizer que quando você der um **git log** você terá a sequencia exata de commits que você realizou.

Imagina fazer isso em um projeto sem ser localmente? O commit de um desenvolvedor pode ir parar 10 logs abaixo de outro, e isso pode bagunçar o projeto e confundir muita gente, mas feito localmente não terá problema algum.

`$ git rebase funcionalidade1`

```
First, rewinding head to replay your work on top of it...
Fast-forwarded master to funcionalidade1.
```

Percebam que primeiro ele primeiro organizou os commits para depois fazer o mesmo trabalho do merge, unindo as modificações do branch funcionalidade1 com o master.

Para verificar este processo, basta rodar um git log e terá o commit do branch funcionalidade1 antes do commit do master. Vale a pena se atentar que não haverá mais o commit do merge, isso quer dizer que estamos gerando um commit a menos.