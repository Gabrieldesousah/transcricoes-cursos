# Brincando com fluxo de commits

Vamos explicar como funciona toda esta estrutura de fluxos de commits.

Nós passaremos por todos os estágios de um commit, vamos fazer o caminho natural do processo e também voltar para que você vá se adaptando e perdendo o medo de trabalhar com sistemas de controle de versão.

Para nossos testes criaremos um outro arquivo, chamado **teste2.txt**. Passando pelo git status nós sabemos que ele estará no estágio de untracked files, por se tratar de um arquivo novo.

Vamos adicionar agora, preparando para o commit. Depois vamos rodar o git status novamente para comprovar que ele se encontra no segundo estágio e pronto para ser comitado.

Agora imagine que você tenha adicionado o arquivo errado e queria reverter esta situação. Ou que você tenha adicionado todos os arquivos, de uma vez, e queira remover apenas um, que não fará parte do commit. Para estes casos, existem os comandos **reset HEAD** e **checkout**. O reset HEAD serve para voltar untracked files e o checkout para voltar arquivos que já foram adicionados e estão modificados.

Fiquem atentos que o Git sempre é muito informativo, e nos ajuda o tempo todo, então ele sempre trará estas possibilidades e dicas.

Como nós criamos um novo arquivo então vamos utilizar o reset HEAD. Veja o comando abaixo:

`$ git reset HEAD teste2.txt`

Depois de rodar este comando, se rodar o git status, você vai ver que ele sai do segundo estágio e volta ao primeiro como Untracked.

Agora vamos simular um outro caso, muito normal no dia a dia do programador, que é adicionar todos os arquivos de uma vez e remover apenas os que não fazem parte. Imagine que temos dez arquivos e oito deles devam fazer parte do commit e dois não. Lógicamente que é mais fácil adicionar todos e remover apenas dois do que ter que adicionar oito manualmente. Então vamos fazer este teste, mas com menos arquivos.

```
$ touch teste3.txt

$ touch teste4.txt
```

Se rodarmos o git status teremos 3 arquivos no estágio untracked files. Vamos adicionar todos com o comando  `$ git add .` e depois remover apenas um deles.

```
valls:aulagit son$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   teste2.txt
    new file:   teste3.txt
    new file:   teste4.txt

valls:aulagit son$
```

Agora vamos remover o teste2.txt para que ele não faça parte do commit. Percebam que o próprio Git está me passando o comando para remover.

`$ git reset HEAD teste2.txt`

```
valls:aulagit son$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   teste3.txt
    new file:   teste4.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

    teste2.txt
```

E depois de preparar todo o seu commit, deixando somente os arquivos que deverão fazer parte dele, basta realizar o commit. Saibam que depois do commit você não consegue mais fazer nada, somente voltar a versão anterior. Então faça tudo que tiver que fazer antes do commit.