# Push e Pull com novo branch

Agora, para finalizar o conceito de push e pull, nós faremos uma simulação para que possa ficar mais fácil o entendimento.

Vamos imaginar que somos uma equipe de colaboradores e temos o repositório **git-code-education**. Para isso devemos ter, pelo menos, dois clones de nosso repositório para simular dois colaboradores.

Para isto crie uma pasta chamada gitCode e mova o repositório clonado no módulo anterior para dentro desta pasta. Depois faça outro clone com o nome de **aulagit**.

```
$ git clone https://github.com/schoolofnetcom/git-code-education.git aulagit
mkdir gitCode
mv aulagit/ gitCode/
mv git-code-education/ gitCode/
```

Nos comandos acima fizemos todas esta configuração. Agora temos uma pasta com dois repositórios idênticos e conectados ao mesmo repositório remoto. Imagine que cada repositório seja um colaborador diferente com máquinas diferentes e que cada um fará uma alteração diferente. Faremos isso para que você entenda o processo e como o Github trabalha.

Agora que temos os dois ambientes iremos fazer uma alteração qualquer em aulagit e subir para o repositório remoto. Depois faremos um alteração no git-code-education e tentaremos subir para o repositório remoto também. Você verá que o primeiro push será aceito, mas o segundo nós não conseguiremos realizar porque primeiro nós teremos que efetuar um comando **pull** para atualizar a alteração, feita em aulagit, e somente depois conseguiremos subir a alteração de git-code-education. Sempre que tiver alguma alteração no repositório remoto, nós deveremos atualizar para depois subir qualquer outra alteração local.

Alteramos o arquivo teste.php, da pasta aulagit, depois comitamos e demos um push para o repositório remoto. Isso quer dizer que o desenvolvedor da pasta git-code-education não possui ainda esta alteração. Para ter certeza disso abra a pasta git-code-education e abra o arquivo que você alterou em aulagit. Você verá que a alteração feita em aulagit ainda não existe.

Para fazer a sincronização você deverá fazer um **pull** que é o inverso do comando push. Dentro da pasta git-code-education, rode o comando abaixo:

`$ git pull origin master`

Depois de rodar este comando você pode abrir novamente o arquivo e você já poderá ver as alterações que você fez, porque agora os dois repositórios estão sincronizados.

Quando se trabalha em equipe, sempre deve-se verificar se o seu repositório local está sincronizado com o repositório remoto e depois você pode enviar suas alterações. Caso queira somente atualizar seu repositório antes de começar a trabalhar basta rodar o **git pull** também.

***

Vamos criar agora um novo arquivo na pasta git-code-education, depois subir para o repositório remoto e depois vamos entrar na pasta aulagit e fazer um pull para pegar este novo arquivo, mas nós faremos isso utilizando um novo branch também.

```
$ git checkout -b novobranch
$ touch arquivo-novobranch.php
$ git add arquivo-novobranch.php
$ git commit -m "Arquivo - exemplo de novo branch"
$ git push origin novobranch
```

Nós executamos os comandos acima, em sequência, para conseguir exemplificar o processo de criação de um arquivo em um novo branch. Então primeiro criamos o branch, depois criamos o arquivo, adicionamos, comitamos e, por último, subimos para o repositório remoto criando um novo branch.

Reparem que, antes de darmos o **push** para o repositório remoto, o branch só existia localmente, mas depois ele foi criado remotamente junto com o comando.

Agora saia do repositório git-code-education e acesse o aulagit. Você poderá ver que não existe o arquivo **arquivo-novobranch.php** nem o branch **novobranch**.

Como já falamos, quando queremos sincronizar com o repositório remoto temos que rodar o comando **pull**. Portanto rode os comandos abaixo:

```
$ git pull
$ git branch -a
$ git checkout -b novobranch origin/novobranch
```

O comando pull sincronizou os repositórios. O **branch -a** rodamos para enxergar os novos branchs para sincronizar também os branchs. E, por último, nós criamos o branch local, com o mesmo nome, e linkamos com o branch online.

Desta forma temos tudo sincronizado, tanto repositório quanto branchs.

> Antes do pull

```
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/funcionalidade1
  remotes/origin/master
```

> Depois do pull

```
  * master
  remotes/origin/HEAD -> origin/master
  remotes/origin/funcionalidade1
  remotes/origin/master
  remotes/origin/novobranch
```

Agora pratique bastante para que você possa dominar estas **idas e vindas** de repositórios locais para repositórios remotos e vice versa.