# Trabalhando com arquivos

Iremos ensinar como utilizar a classe de arquivos neste módulo. Então você terá acesso a como manipular arquivos, em sua aplicação, utilizando a API nativa do Node.

É muito importante saber manipular arquivos porque existem alguns módulos que necessitam da leitura do file system para carregar os seus módulos. Um exemplo que podemos citar é o **Sequelize**, um ORM que utiliza um banco de dados.

# Criando arquivos

Criaremos um arquivo chamado **file.js**. A partir disso vamos tentar simular alguns problemas para ir resolvendo em seguida. Desta forma você conseguirá entender melhor.

Imagina que precisemos escrever dentro de um arquivo. Vamos escrever qualquer tipo de string dentro de um arquivo utilizando o **file system**. Veja o código abaixo:

```js
var fs = require('fs');

fs
    .writeFile('data.txt' , 'Hello world from SON' , function (err) {
        if(err){
            throw err;
        }
    });
```

Reparem que primeiro importamos a classe **File System** e atribuímos a variável **fs**. Depois utilizamos o método **writeFile** com os seguintes parâmetros:

1. Nome do arquivo
2. Conteúdo do arquivo
3. Função que recebe um erro como parâmetro

Depois fizemos uma verificação. Se existir erro a função irá mostrá-lo, senão segue o fluxo da programação.

É muito importante informar que todas as API são assíncronas, mas existem métodos que são síncronos. Você pode escolher de acordo com sua necessidade de momento.

# Lendo arquivos

Agora que criamos um arquivo, com um conteúdo, precisamos ler este arquivo. É isso que iremos lhe mostrar agora.

```js
var fs = require('fs');

fs
    .readFile('data.txt', function (err,data) {
        if(err){
            throw err;
        }
        console.log(data.toString('utf8'));
    });
```

A leitura de um arquivo é muito semelhante a criação. Percebam que apenas alteramos o método para **readFile** e depois passamos dois parâmetros:

1. Caminho do arquivo em sua estrutura de pastas
2. Função que recebe um erro(err) e o conteúdo do arquivo que foi lido(data)

Depois fizemos a mesma verificação do erro, caso não tenha o erro estamos imprimindo o conteúdo como string na codificação utf8.

Como nosso arquivo criado esta na mesma pasta do nosso arquivo **file.js** não precisamos colocar o caminho relativo, mas saiba que se tiver uma estrutura de pastas mais complexa você deverá passar o endereço completo do arquivo para que a leitura possa ser concluída.

# Lendo arquivos de um diretório

```js
.readdir('.', function (err,files) {
    if(err){
        throw err;
    }

    for (var file in files){
        console.log(files[file]);
    }
});
```

Com o método **readdir** nós conseguimos ler todos os arquivos que estiver dentro do diretório que quisermos, basta passar o caminho do diretório no primeiro parâmetro e depois uma função que recebe **err** e **files**, assim como as anteriors.

Depois percorremos, o resultado, com uma estrutura de repetição **for** e obtivemos todos os arquivos e pastas presentes dentro do nosso diretório raiz.

# Filtrando resultados

```js
.readdirSync('.')
.filter(function (file) {
    return (file.endsWith('.js'));
})
.forEach(function (file) {
    console.log(file);
});
```

Percebam que utilizamos o mesmo método, porém de forma **síncrona** e filtramos somente os arquivos terminados em **.js**. Desta forma trabalhamos com filtros e acabamos lendo somente os arquivos filtrados.

Percebam que não existe segredo nenhum ao trabalhar com arquivos no Node.