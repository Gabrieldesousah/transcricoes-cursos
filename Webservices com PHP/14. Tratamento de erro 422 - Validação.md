# Tratamento de erro 422 - Validação

Imagine agora que queiramos trabalhar com validação de dados.

A arquitetura REST prevê o que temos que fazer, mas não tem um modo definido de ser feito. Então toda tratativa de erros nós devemos implementar diretamente nos métodos que criarmos.

O Lumen já possui um método para nos ajudar. O método é chamado de **Validate** e ele nos ajuda a receber a mensagem na resposta e com os erros já formatados além do status code correto.

Lembrando que quando o usuário envia um dado inválido, o erro é do lado do cliente e não mais no servidor. O cliente, teóricamente, não deveria enviar este dado errado. Por este motivo devemos escolher um erro da família dos **400** como status code.

Então vamos começar a aplicar a tratativa no método store, que é nosso método de criação.

```php
public function store(Request $request)
{
    $this->validate($request, [
        'name' => 'required',
        'email' => 'required',
        'phone' => 'required',
    ]);

    $client = Client::create($request->all());
    return response()->json($client,201);
}
```

Desta forma estamos tornando os campos todos obrigatórios. Anteriormente se o usuário enviasse algum campo vazio, a API aceitaria e cadastraria o usuário.

```json
{
    "name": "Luiz Carlos",
    "email": "luiz@schoolofnet.com",
    "phone": ""
}
```

Imagina que o usuário esteja mandando uma requisição com os dados acima. Como o telefone é um campo obrigatório, não será permitido um valor nulo e a API retornará o seguinte erro:

```json
{
  "phone": [
    "The phone field is required."
  ]
}
```

![web_service_postman_validate](./images/web_service_postman_validate.png "web_service_postman_validate")

Faça o teste no Postman enviando um cadastro com algum campo em branco. Você poderá conferir o erro acima.

Reparem que o Lumen gera o status code 422, que informa o não processamento da requisição por falta de dados para o recurso.

Faremos a mesma validação para o método update, mas adicionaremos depois da primeira validação, que testa se o id passado existe realmente.

```php
public function update($id , Request $request)
{
    if(!($client = Client::find($id))):
        throw new ModelNotFoundException("Client requisitado não existe");
    endif;

    $this->validate($request, [
        'name' => 'required',
        'email' => 'required',
        'phone' => 'required',
    ]);

    $client->fill($request->all());
    $client->save();
    return response()->json($client,200);
}
```

Agora estamos com os dois métodos validados.

Existem algumas APIs que retornam um status code 200, mas com uma mensagem de erro. Isso funciona, mas temos um erro de semântica neste procedimento. Como uma API retorna um erro com status 200? Sendo que 200 é um sucesso.

Nós precisamos ficar atentos a estes pequenos detalhes, porque se tem um sucesso não pode haver um erro e o contrário também se aplica.