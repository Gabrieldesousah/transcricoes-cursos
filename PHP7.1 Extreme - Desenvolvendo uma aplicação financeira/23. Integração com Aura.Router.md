# Integração com Aura.Router

Chegamos a uma parte muito importante que é nossa estrutura de rotas.

Utilizaremos uma biblioteca chamada Aura.Router para nos auxiliar nesta estrutura. Este biblioteca é muito famosa na comunidade.

Como já falamos, não utilizaremos aquele velho estilo de acessar o script PHP diretamente, por estar ultrapassado e também por questões de segurança da aplicação. Por este motivo vamos utilizar uma biblioteca para trabalhar com rotas amigáveis, desta forma o usuário não sabe qual arquivos está acessando.

Nós trabalharemos com a arquitetura MVC, em nosso projeto, e esta arquitetura já é bem antiga, foi criada no final da década de 70. Esta arquitetura foi perfeita para web, para que consigamos organizar nossas aplicações. Sem esta arquitetura os programadores poderiam criar um arquivos apenas e misturar PHP com HTML onde teria toda regra de negócio junto com a parte visual do projeto.

O MVC é um acrônomo para **Model**, **View** e **Controller**. Então nossa aplicação será segmentada em três partes.

Elemento | Descrição
------------- | -------------
Models | Responsável por gerenciar os dados da aplicação incluindo adição, edição e remoção do banco de dados
Views | Responsáveis apenas por mostrar informações na tela do usuário
Controllers | Responsável por receber a requisição da View, buscar os dados no Model e retornar os dados para View

É nesta hora que a biblioteca **Aura.Router** nos ajudará. Esta biblioteca permite a criação de rotas onde nós definiremos o acesso aos controllers e consequentemente teremos o retorno das views, para o usuário, com os conteúdos corretos, que vieram do Model.

Para instalar esta biblioteca rode o comando abaixo em seu terminal:

`composer require aura/router:3.1.0`

Mantenham as mesmas versões, para que não tenham problemas de compatibilidade no futuro.

### Criando primeiro plugin

O nosso primeiro plugin será o plugin de rotas. Dentro da pasta **src/Plugins** crie uma classe chamada **RouterPlugins.php**.

```php
<?php
namespace SONFin\Plugins;

use Aura\Router\RouterContainer;
use SONFin\ServiceContainerInterface;

class RoutePlugin implements PluginInterface
{

    public function register(ServiceContainerInterface $container)
    {
        $routerContainer = new RouterContainer();
        /* Registrar as rotas da aplicação */
        $map = $routerContainer->getMap();
        /* Tem a função de identificar a rota que está sendo acessada */
        $matcher = $routerContainer->getMatcher();
        /* Tem a funão de gerar links com base nas rotas registradas*/
        $generator = $routerContainer->getGenerator();

        $container->add('routing', $map);
        $container->add('routing.matcher', $matcher);
        $container->add('routing.generator', $generator);
    }
}
?>
```

Percebam que estamos implementando a interface **PluginInterface** para implementar o método **register**, onde passaremos um **ServiceContainerInterface** como injeção de dependência para o método.

Depois, no método register, estamos instanciando a variável **$routerContainer** com a classe **RouterContainer**, da biblioteca **Aura**.

Desta forma conseguimos atribuir a variável **$map** o método **getMap**, atribuímos o método **getMatcher** para a variável **$matcher** e o método **getGenerator** para variável **$generator**.

Depois de atribuir os métodos as variáveis basta que utilizemos o método **add** para adicionar os métodos ao nosso container de serviços. Percebam que passamos um identificador, como primeiro parâmetro, e depois passamos a variável com o método atribuído.

O método **getMap** tem a função de registrar as rotas da aplicação.

O método **getMatcher** tem a função de rastrear a rota acessada para ver se a mesma existe, caso exista ele faz o relacionamento e o processamento.

O Método **getGenerator** serve para fazer um redirecionamento de rotas com base nas rotas registradas. Este método pode parecer obscuro agora, mas quando utilizarmos você entenderá melhor. Por enquanto apenas deixe ele registrado em nosso plugin.

### Conclusão

Ainda existem alguns registros para fazer no plugin e também teremos que utilizar o plugin em nossa classe Application. Ainda temos um longo caminho de configuração até que consigamos ter um resultado, através de rotas, no browser.

Daremos continuidade no próximo módulo.