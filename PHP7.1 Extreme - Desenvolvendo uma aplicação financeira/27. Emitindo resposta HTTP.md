# Emitindo resposta HTTP

Agora que já fizemos toda configuração de rotas, atributos e também estamos recebendo a request nas ações das rotas, porém para mostrar o resultado para o usuário, não podemos trabalhar com **echo**, como estamos fazendo agora. Trabalhar com a arquitetura MVC  exige que criemos uma resposta mais elaborada para o usuário.

A resposta HTTP possui um **status code**, vai ter seu conteúdo, possui seu devido cabeçalho e o zend-diactoros nos fornece todas estas informação. Então ao invés de trabalhar com uma resposta com **echos** ou estruturas HTML na função, nós criaremos uma resposta padronizada e automatizada.

Integraremos a resposta com a nossa classe Application. Então voltaremos até a classe Application e criaremos um método para configurar esta resposta.

```php
protected function emitResponse(ResponseInterface $response){
    $emitter = new SapiEmitter();
    $emitter->emit($response);
}
```

Percebam que se trata de um método protegido, porque ele só será acessado dentro da classe. Este método recebe uma ResponseInterface como parâmetro e este resposta vem da PSR-7 **Psr\Http\Message**.

Dentro deste método estamos instanciando uma classe chamada **SapiEmitter** e não PHP quando falamos Sapi estamos querendo dizer **S**erver **API**. Isso quer dizer que vamos pegar os dados de uma server api para enviar como resposta para a requisição.

Depois temos que modificar o método **start** também.

```php
public function start(){
    $route = $this->service('route');
    /** @var ServerRequestInterface $request */
    $request = $this->service(RequestInterface::class);

    if(!$route){
        echo "Page not found";
        exit;
    }

    foreach ($route->attributes as $key => $value){
        $request = $request->withAttribute($key,$value);
    }

    $callable = $route->handler;
    $response = $callable($request);
    $this->emitResponse($response);
}
```

Criamos uma variável, chamada **$response**, e atribuímos o nossa resposta atual que vinha do **$callable($request)**. Depois basta chamar o método **emitResponse** passando esta variável response, que é do tipo ResponseInterface.

O método se encarregará de enviar a resposta HTTP, para nossa rota, então temos que ir até a rota e mostrar a resposta para o usuário.

```php
$app->get('/home/{name}/{id}', function(ServerRequestInterface $request){
    $response = new \Zend\Diactoros\Response();
    $response->getBody()->write("response com emmiter do diactoros");
    return $response;
});
```

Como já configuramos a response, com o SapiEmitter, quando instanciamos o **Zend\Diactoros\Response()** nós já temos a resposta formada então basta adicionarmos alguma mensagem, com o método **getBody** e passa a mensagem que quisermos.

E, por último, retornamos a response.

Agora que já temos esta estrutura pronta nós podemos começar a trabalhar com nossas **views** do padrão **MVC**.

### Função do método start

Para exemplificar a estrutura da nossa aplicação precisamos entender o papel fundamental que o método start tem.

O start vai pegar a rota acessada através da requisição, depois vai verificar se a rota existe ou não. Caso não existe ele mostra que a rota não existe, mas se existir ele pega os parâmetros/atributos da rota e adiciona na requisição.

Depois o método acessa a **action** da rota, chama esta action com a resposta e emite para a rota novamente.

Vocês podem ver a importante que a classe **Application** tem para a aplicação, ela está gerenciando toda aplicação sem que fiquemos preocupados com o que pode ou não acontecer.

O nosso objetivo é configurar um pouco mais esta classe e depois não mexer mais nela, apenas teremos que ir adicionando os plugins, porém o restante já estará totalmtente configurado.

Próximo passo será trabalharmos com o **Twig**, que será a template engine que nos auxiliará na criação do front-end da aplicação.