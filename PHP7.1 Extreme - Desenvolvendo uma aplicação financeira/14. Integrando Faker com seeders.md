# Integrando Faker com seeders

No módulo passado nós criamos a primeira seeder da nossa aplicação. Entendemos que a seeder semeará nossa aplicação com dados de teste e que o ideal é utilizar somente em ambiente de desenvolvimento.

Do jeito que estamos trabalhando já está ótimo, porque podemos ter os dados de teste criados e destruídos a hora que quisermos, mas imagina se fosse uma gama maior de dados a serem criados. Por mais que seja simples, nós ainda deveríamos ficar duplicando os arrays dentro do nosso arquivo seed e este processo ainda seria muito manual. Para isso existe uma outra ferramente, muito conhecida, chamada **Faker**. Nós adicionaremos esta biblioteca ao nosso sistema para otimizar ainda mais a criação de dados testes para nossas seeders.

Esta biblioteca nos proporciona dados de teste de diversos tipos como: telefone, email, nome, data e muito mais.

Além dos modelos pronto, que a ferramenta disponibiliza, nós ainda podemos criar nossos próprios modelos como **CPF**, por exemplo. Basta cria um provider para este novo modelo.

O Faker é utilizado por muitos frameworks e muitos outros projetos.

Vamos rodar um comando para instalar a biblioteca em nosso projeto, mas gostaríamos de lembrar que, em um projeto, existem dois tipos de denpendências: produção e desenvolvimento.

A biblioteca Faker será uma dependência de desenvolvimento apenas, desta forma quando fizermos o deploy para o ambiente de produção ela não será instalada. Então é muito importante diferencias as dependências do nosso projeto.

O Composer trabalhar esta diferenciação de uma forma muito simples. Veja o comando abaixo:

`composer require fzaninotto/faker:1.6.0 --dev`

O parâmetro **--dev** informa, para o Composer, que esta biblioteca deve ser instalada somente no ambiente de desenvolvimento.

Se analisar o próprio Faker tem alguma dependência de desenvolvimento, em seu arquivo composer.json, o phinx também possui, mas quando instalamos estas bibliotecas as dependências de desenvolvimento não são instaladas, somente as de produção. O mesmo acontecerá em nossa aplicação.

### Implementando Faker em nossa Seeder

```php
use Phinx\Seed\AbstractSeed;
class CategoryCostsSeeder extends AbstractSeed
{

    public function run()
    {
        $faker = \Faker\Factory::create('pt_BR');
        $categoryCosts = $this->table('category_costs');
        $data = [];
        foreach (range(1, 10) as $value) {
            $data[] = [
                'name' => $faker->name,
                'created_at' => date('Y-m-d H:i:s'),
                'updated_at' => date('Y-m-d H:i:s')
            ];
        }
        $categoryCosts->insert($data)->save();
    }
}
```
Percebam que atribuímos o método **create** vindo de **\Faker\Factory** e passamos a linguagem pt_BR, porque o Faker já trabalha com várias linguagens. Isso quer dizer que os dados serão gerados já em português.

Depois fizemos um foreach para gerar 10 arrays de teste. Assim não precisamos criar 10 arrays manualmente.

Percebam que somente o nome está sendo gerado pelo faker, mas poderiam existir outros tipos de dados.

Depois de gerar todos os arrays, nós utilizamos o mesmo método **insert**, mas passamos a nossa variável **$data**, que contém todos os dados que serão criados.

Depois disso basta rodar o comando de execução da seeder novamente. Caso queira que os dados comecem com **ID** = 1, você deverá destruir a tabela, com o **rollback** e depois gerar a migration novamente e, em seguida, executar a seeder.

Você pode perceber que não é necessário adicionar o campo de chave primária, no momento em que criamos as migrations, porque este campo já é criado por default. Desta forma qualquer tabela criada sempre terá o campo ID com auto-incremento.

`vendor/bin/phinx seed:run`

Depois de rodar este comando acesse novamente o MySQL e rode o comando de select. Você terá acesso aos novos dados adicionados.

O phinx com o Faker acaba facilitando demais a nossa vida na criação de conteúdos testes. Vejam que com apenas uma classe nós estamos gerando 10 dados de teste. Caso queira criar 100 dados basta modificar o valor do range do foreach.