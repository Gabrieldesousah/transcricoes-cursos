# Criação da classe Application

Agora que já temos o container de serviços devidamente configurado, vamos dar proceguimento ao desenvolvimento.

Agora chegamos a outra parte crucial de nosso desenvolvimento. O container de serviços terá a função apenas de guardar os serviços e disponibilizá-los, mas ainda precisamos criar um centralizador de classes, para que não fique nada jogado na aplicação, então teremos uma classe que centralizará tudo em nossa aplicação.

Crie uma classe, dendo da pasta src, chamada **Application.php**. A priore esta classe será uma instância do nosso ServiceContainerInterface e para fazer esta ligação nós utilizaremos o conceito de Dependancy Injection, ou injeção de dependência.

```php
<?php
declare(strict_types = 1);
namespace SONFin;

class Application
{
    private $serviceContainer;

    /**
     * Application constructor.
     * @param $serviceContainer
     */
    public function __construct(ServiceContainerInterface $serviceContainer)
    {
        $this->serviceContainer = $serviceContainer;
    }

    public function service($name)
    {
        return $this->serviceContainer->get($name);
    }

    public function addService(string $name, $service)
    {
        if (is_callable($service)) {
            $this->serviceContainer->addLazy($name, $service);
        } else {
            $this->serviceContainer->add($name, $service);
        }
    }
}
?>
```

Nós poderíamos instanciar um objeto no construtor, mas isso faria que nossa classe ficasse muito dependência de uma classe e isso não é uma boa prática por engessar demais seu código e dificultar manutenção. Muito melhor criarmos a injeção de dependência ainda mais relacionando com uma interface, porque qualquer classe que implementar a mesma interface poderá ser injetada. Isso torna o código muito mais versátil e reaproveitável.

Além de fazer a injeção de dependência no construtor nós estamos adicionando dois métodos: service e addService. Este métodos servem para que possamos gerenciar serviços através da classe Application, mas percebam que estamos integrando com nosso conceito padrão de container de serviços, girando sempre em torno dos mesmo métodos. O método **service** serve para resgatar um serviço e o **addService** para adicionar tanto um serviço padrão quando um Lazy.

Depois destas configurações vamos começar a trabalhar com rotas em nossa aplicação. Trabalharemos com rotas amigáveis e não acessaremos scripts PHP diretamente. Não utilizaremos este padrão porque torna a aplicação muito vulnerável, se o usuário sabe o arquivo que está sendo acessado ele pode mapear nossa aplicação.

A classe Application será responsável por gerenciar nossas rotas. Porém nós faremos de uma maneira que a classe Application possa extender outra classe, adicionando novas funcionalidades, sem que o tamanho da mesma aumente. Este é um conceito SOLID para aplicar boas práticas ao projeto.

Continuaremos no próximo módulo fazendo alguns testes e já veremos alguns resultados no browser.