# Criando plugins

Vamos falar de um assunto muito legal, deste conteúdo, que vai ser a extensão de funcionalidade de uma classe. Este é um conceito de SOLID, como foi dito no módulo anterior.

Dentro da sigla SOLID, estaríamos trabalhando com a letra **O**, que significa **Open Closed Principle**. As vezes este conceito é muito complicado de se entender e também existem algumas classes que acabam não permitindo aplicar esta funcionalidade, caso você não conheça o conceito e crie a classe não preparada para ele.

Este princípio diz que quando criamos uma classe nós temos que ser capazes de extender novas funcionalidades a esta classe sem que alteremos a essência da mesma. Quando você precisa adicionar uma funcionalidade a uma classe e existe a necessidade de alterar esta classe inteira, pode parar e reavaliar porque existe uma grande possibilidade de estar programando de forma errada e de estar adicionando um bug em sua classe.

Então vamos trabalhar com este princípio na classe Application. Nós queremos uma classe que possa ter adições de outras classes, integração com outras bibliotecas de maneira que não precisemos ficar mexendo muito nela.

Então nós trabalharemos com plugins, para conseguir atingir nosso objetivo.

Se quisermos fazer alguma integração com a classe Application nós adicionaremos um **plugin** a esta classe e assim não precisaremos fazer nenhuma alteração muito grande para executar a integração. Este plugin terá uma interface e um método para realizar alguns registros, então a classe Application recebe o plugin, registra o que tiver que registrar e pronto.

Imagine que está adicionando um complemento para um navegador, este complemento não pode modificar o funcionamento do navegador, apenas deve adicionar alguma funcionalidade e também deve seguir algumas regras.

A lógica do plugin deve ser a mesma, a base da classe Application não deve ser alterada devemos apenas adicionar o plugin para melhorá-la.

### Integrando plugins

Crie uma pasta, chamada **Plugins**, dentro da pasta src. Todos os plugins necessários serão adicionados nesta pasta e todos eles implementarão uma interface. Então, dentro da pasta Plugins, cria um uma interface chamada **PluginInterface.php**.

```php
<?php
namespace SONFin\Plugins;
use SONFin\ServiceContainerInterface;
interface PluginInterface
{
    public function register(ServiceContainerInterface $container);
}
?>
```

Percebam que os plugins terão comunicação com nossa classe **Application** através do nosso container de serviços. Pois estamos injetando a interface ServiceContainerInterface no método **register**.

Adicionando método de instalação na classe Application:

```php
public function plugin(PluginInterface $plugin): void
{
    $plugin->register($this->serviceContainer);
}
```

Adicionando este método a classe Application auto-registrará os plugins. Olha o nível de facilidade que temos para adicionar funcionalidades em nossa classe principal, sem que ela fique gigantesca. Desta forma temos uma super classe e com código reduzido.

Com o PHP 7.1 podemos informar o tipo de retorno de uma função e como a função não retornará nada passamos **void**, o mesmo acontece com o método **addService**.

```php
public function addService(string $name, $service): void
{
    if (is_callable($service)) {
        $this->serviceContainer->addLazy($name, $service);
    } else {
        $this->serviceContainer->add($name, $service);
    }
}
```

Pode parecer que não tem motivo para utilizar este recurso, mas é interessante bater o olho na função, ou método, e saber que ele apenas executa seu papel, sem retornar nenhum valor.

Antes desta versão nós não sabiamos se tinha valor retornado e, se tinha, não sabíamos de qual tipo ele era.

### Conclusão

Já criamos a base para integração de plugins, agora nós começaremos a criar plugins para adicionar a nossa aplicação. Pode ser que esteja um pouco confuso agora, mas você vai começar a entender melhor na prática, quando começarmos a instalar os novos plugins.

Você entenderá o conceito de plugins e containers, fiquem tranquilos.