# Serviço para renderizar templates

No último módulo nós deixamos o Twig integrado e registrado em nosso container de serviços.

Nós poderíamos muito bem utilizar o renderizador do Twig para mostrar nossas views, mas nós criaremos o nosso próprio renderizador.

Nós utilizaremos esta renderização a todo momento nas ações das rotas.

Para iniciarmos vamos criar uma pasta, chamada **View**, dentro da pasta **src**. Dentro desta pasta criaremos uma interface e um serviço, mas primeiro criaremos a interface.

O arquivo chamará **ViewRenderInterface.php**.

```php
<?php
declare(strict_types = 1);
namespace SONFin\View;

use Psr\Http\Message\ResponseInterface;

interface ViewRendererInterface
{
    public function render(string $template, array $context = []): ResponseInterface;
}
?>
```

A nossa interface terá apenas um método que renderizará o nosso template. Rederizar é pegar todo conteúdo que vem do Twig, inclusive parâmetros, e transformar em string, todo conteúdo, para sem mostrado no navegador para o usuário.

Vejam que nosso método **render** recebe o template e um contexto, que a princípio é um array vazio. Este contexto são valores que serão utilizados para serem renderizados no template, caso existam. Estes dados podem ser elementos simples, mas também podem ser coleções de dados vindos de um banco de dados, por exemplo.

Nós estamos definindo, através do strict type, que o retorno do método será uma ResponseInterface, seguindo a PSR-7. Isso quer dizer que não interessa qual será o template engine que estaremos utilizando, estamos configurando o comportamento que deverá existir em nosso método.

Agora que já temos a interface, criaremos o nosso renderizador. Crie uma classe chamada **ViewRenderer.php**.

```php
<?php
namespace SONFin\View;

use Psr\Http\Message\ResponseInterface;
use Zend\Diactoros\Response;

class ViewRenderer implements ViewRendererInterface
{
    /**
     * @var \Twig_Environment
     */
    private $twigEnviroment;

    /**
     * ViewRenderer constructor.
     */
    public function __construct(\Twig_Environment $twigEnviroment)
    {
        $this->twigEnviroment = $twigEnviroment;
    }

    public function render(string $template, array $context = []): ResponseInterface
    {
        $result = $this->twigEnviroment->render($template, $context);
        $response = new Response();
        $response->getBody()->write($result);
        return $response;
    }
}
?>
```

Como nosso renderizador irá renderizar o template vindo do Twig, nós precisaremos do renderizador do Twig sendo passado como parâmetro para nosso construtor. Desta forma estaremos trabalhando com injeção de dependênca.

Desta forma nós setamos o atributo privado **twigEnvironment** com a instância do twig no construtor. Todo processo está sendo centralizado nos serviços, você pode perceber que os dados já estão prontos para serem utilizados em nossas demais classes.

O que nos interessa, no momento, é o método render.

Percebam que estamos guardando o resultado em uma variável. Esta resposta se trata do template do twig junto com o contexto envolvido.

Depois nós iniciamos uma response da PSR-7, escrevemos esta resposta e a retornamos. Nossa estrutura está praticamente pronta, conforme formos evoluindo retornaremos o HTML prontinho para a view, por enquanto estamos retornando apenas textos simples.

Vamos agora configurar o serviço ViewRenderer porque vamos precisar usá-lo nas rotas e precisamos dos dados do Twig para formar a resposta.

Voltamos ao arquivo **ViewPlugin.php**.

```php
class ViewPlugin implements PluginInterface
{

    public function register(ServiceContainerInterface $container)
    {
        $container->addLazy('twig', function (ContainerInterface $container) {
            $loader = new \Twig_Loader_Filesystem(__DIR__ . '/../../templates');
            $twig = new \Twig_Environment($loader);
            return $twig;
        });

        $container->addLazy('view.renderer', function (ContainerInterface $container) {
            $twigEnviroment = $container->get('twig');
            return new ViewRenderer($twigEnviroment);
        });

    }
}
```

O primeiro método já estava configurado, nossa atenção deve ser para o segundo método. Vejam que também se trata de um registro de serviço do tipo Lazy.

Depois nós atribuímos a uma variável, chamada $twigEnviroment, onde utilizamos o container para recuperar os dados do serviço registrado anteriormente. Registramos como **view.renderer**.

Este método retornará uma instância da classe ViewRenderer onde passamos a instância do Twig, como tínhamos visto anteriormente.

Desta forma terminamos de configurar nosso plugin renderizador. Agora basta registrar o plugin, em nosso arquivo index.php, da mesma forma que o plugin de rotas.

```php
$app->plugin(new RoutePlugin());
$app->plugin(new ViewPlugin());
```

Para testar vamos criar um template e utilizá-lo em nossa rota.

Crie um arquivo chamado **test.html.twig**, percebam que, em nossos templates, sempre teremos que utilizar a extensão **.twig**. Este é o padrão do twig, se for utilizar outra template engine você deverá seguir o padrão imposto por ela. Mesmo o arquivo sendo do tipo html, nós utilizamos as duas extensões.

```html
<h1>{{ name }}</h1>

{{ 'Twig funcionando' }}
```

O interpolador **{{ }}** faz a lógica PHP para imprimir a variável **name** que será passado como contexto pela rota. Desta forma o interpolador pode imprimir variáveis ou textos, como pode ver no template acima.

Com nosso template criado, rotas e renderizador configurados, vamos fazer nosso primeiro teste completo reunindo todas as funcionalidades. Adicione uma nova rota ao arquivo index.php:

```php
$app->get('/{name}', function(ServerRequestInterface $request) use($app){
    $view = $app->service('view.renderer');
    return $view->render('test.html.twig', ['name' => $request->getAttribute('name')]);
});
```

Vejam que estamos passando um parâmetro **name** para a rota. Logo depois estamos resgatando o serviço renderizador para a variável **$view**. Depois basta retornar o método **render** passando o nome do template e logo depois um array com os atributos a serem utilizamos da view.

Não é necessário passar o caminho inteiro do template, porque nós já informamos, ao serviço, onde estão os templates. Desta forma basta passar o nome.

É possível trabalhar com mais de um caminho para templates também, basta configurar outro caminho, mas em nosso caso teremos todos os templates centralizados em apenas uma pasta.

Agora você pode subir o servidor novamente e acessar a rota abaixo:

`php -S localhost:8000 -t public public/index.php`

Acessar: **http://localhost:8000/name**

Desta forma você terá, como resultado, o nosso template já renderizando o conteúdo dinâmicamente, ou seja, se modificar o parâmetro **name** da URL teremos o resultado renderizado dinamicamente.

Caso queiramos criar uma rota sem parâmetros e mesmo assim passar um valor dinamicamente é possível, da seguinte forma:

```php
$app->get('/', function() use($app){
    $view = $app->service('view.renderer');
    return $view->render('test.html.twig', ['name' => 'Luiz Carlos']);
});
```

A partir de agora podemos começar a trabalhar com templates HTML utilizando Bootstrap e toda estrutura para formar layouts robustos, de acordo com a proposta de nosso projeto.