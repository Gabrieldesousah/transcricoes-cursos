# Interface de container de serviços

Durantes os últimos capítulos nós iniciamos nossa aplicação, na prática. Preparamos nosso ambiente, falamos sobre Composer e sobre as diferenças entre a PSR-0 e PSR-4.

Nós já criamos a primeira migration e também já geramos os dados iniciais, com a seed, gravando no banco de dados. O próximo passo será criar o gerenciamento destes dados, que chamamos de CRUD.

Este momento é crucial de nosso desenvolvimento, porque ainda não criamos nada na pasta **src** do nosso projeto e dependendo de como iniciarmos o projeto, poderemos ter problemas futuros. Se não soubermos estruturar de uma forma correta nós começaremos a sofrer e ter bugs inesperados, a todo momento, em nossa aplicação. Estes erros podem nos desmotivar, tornar o desenvolvimento cansativo ou até mesmo tornar o desenvolvimento inviável.

Então temos que pensar muito antes de criar o esqueleto da aplicação e quando falando em esqueleto, estamos falando da base que vai permitir toda integração, gerenciar componentes e todos os outros processos. Este esqueleto deve nos ajudar e não atrapalhar.

Vamos começar por um conceito, muito importante, que aplicação que não o utilizam tendem a dar muitas voltas até chegar onde se quer chegar. Vamos começar a trabalhar com o conceito de **Container de Serviços**.

Talvez para quem é iniciante, este conceito seja um pouco complicado a princípio, mas um serviço é algo que vai ser reaproveitado em toda aplicação. Será uma instância que poderá ser utilizada a qualquer momento e ser integrada com outras funcionalidades também.

Isso implica em termos uma gama de serviços prontos para serem utilizados, de forma organizada, a hora que for preciso e onde for preciso. Outra característica muito importante é a facilidade de chamar este serviço, tem que ser uma forma fácil de se acessado.

Um exemplo que podemos cita é durante o processo de desenvolvimento de uma aplicação em PHP, onde não trabalhamos com container de serviços, então temos que toda hora ficar instanciando classes para utilizar algum recurso que você precisa.

Então, como neste projeto vamos trabalhar com boas práticas de programação, trabalharemos com SOLID e com um nível alto de abstração, trabalharemos bastante com interface também.

Desta forma o nosso container terá que implementar uma interface, para que consigamos organizar este container de modo que possamos ter outros containers com outros tipos de implementação. A interface vai apenas guiar a implementação do container de serviço.

Vamos criar esta interface, dentro da pasta src. O arquivo de interface terá o nome de **ServiceContainerInterface.php**.

```php
<?php
declare(strict_types = 1);
namespace SONFin;

interface ServiceContainerInterface
{
    public function add(string $name, $service);

    public function addLazy(string $name, callable $callable);

    public function get(string $name);

    public function has(string $name);
}
?>
```

Percebam que estamos listando os métodos que queremos que sejam a assinatura de nossos containers. Criamos um método para adição que é o **add**, adição do formato **Lazy** que se trata do **addLazy** e explicaremos posteriormente, um método **get** para pegar o serviço e o método **has**, para verificar se existe um serviço com determinado nome.

Estamos utilizando o **declare(strict_types = 1)** para podermos utilizar o recurso do PHP 7.1. O PHPStorm, que estamos utilizando como IDE, já tem o devido suporte a esta versão da linguagem, então qualquer erro ele nos alertará, se sua IDE não possui suporte fique mais atentos na hora de digitar o código.

Percebam que não tem nada de muito complexo nesta interface. no método add estamos passando um nome para registro e o serviço, o addLazy também estamos passando nome e uma função que será informada e posteriormente o método get e o has também recebem o nome como parâmetro. Percebam que estamos passando o Type Hinting na frente dos nomes, porque temos certeza que estes campos seão strings,

Nós não criaremos um container de serviço do zero, mas trabalhar desta forma nos permite trocar de container a hora que quisermos, se for necessário. Quando você trabalha voltado para interface você vai usar a interface ao invés da implementação. Caso tenha alguma mundança na implementação sua aplicação não sofrerá nenhuma interferência, evitando bugs.

Olhando para o conceito de SOLID, quando começamos a trabalhar com interface em específico estamos tarbalhando com o princípio da segregação da interface, quanto mais criarmos interfaces, para resolver um problema específico, mais organizada estará nossa aplicação. Não estamos criando uma interface para ser a grande solução da aplicação inteira, estamos criando para resolver um problema, em específico, por exemplo.

Uma classe pode extender de apenas uma classe, mas podemos implementar quantas interfaces nós quisermos, esta é a vantade do usa de interfaces em um projeto. Então quando começamos a trabalhar com interfaces nós começamos a agregar comportamentos para nossas classes, interfaces específicas permitem que consigamos reaproveitar o compartamento em diversas outras classes.

Nossa interface está criada, agora vamos começar a implementar o container de serviços utilizando esta interface.