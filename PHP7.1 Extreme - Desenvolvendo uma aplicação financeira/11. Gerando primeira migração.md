# Gerando primeira migração

No módulo passado adicionamos as configurações, retornando-as em um formato de array.

Então agora rodaremos a linha do comando do **phinx** para, finalmente, criar nossas migrações. Esta ferramenta precisa receber algumas configurações para que possamos apontar qual que é a pasta, que ela vai começar a gerar as migrações, precisa saber qual é a tabela do banco de dados que ela vai controlar e ela precisa saber as credenciais do banco, para fazer a conexão.

Existem 3 maneiras de configurar o phinx, criando arquivos dos tipos:

1. json
2. yml
3. php

Estes arquivos são necessários, porque algumas configurações que a biblioteca utiliza pode ser diferente das configurações que relacionamos no arquivo db.php. Então teremos que manipular estes dados antes de enviar as informações.

Portanto crie um arquivo, chamado phinx.php, na raiz da nossa aplicação.

Quando você rodar qualquer comando no phinx, os primeiros arquivos que ele irá procurar serão um destes 3 arquivos, citados acima.

```
require __DIR__ . '/vendor/autoload.php';
$db = include __DIR__ . '/config/db.php';
list(
    'driver' => $adapter,
    'host' => $host,
    'database' => $name,
    'username' => $user,
    'password' => $pass,
    'charset' => $charset,
    'collation' => $collation
    ) = $db['development'];
return [
    'paths' => [
        'migrations' => [
            __DIR__ . '/db/migrations'
        ],
        'seeds' => [
            __DIR__ . '/db/seeds'
        ]
    ],
    'environments' => [
        'default_migration_table' => 'migrations',
        'default_database' => 'development',
        'development' => [
            'adapter' => $adapter,
            'host' => $host,
            'name' => $name,
            'user' => $user,
            'pass' => $pass,
            'charset' => $charset,
            'collation' => $collation
        ]
    ]
];
```

O primeiro ponto, que temos que nos atentar, é chamar o autoload, para termos acesso as classes do phinx.

Depois nós atribuímos as informações de credenciais, do banco de dados, a uma variável chamada **$db**. Lembrando que sempre devemos utilizar o **__DIR__** para pegar sempre o caminho absolutdo do arquivo atual. Desta forma estamos informando o caminho do arquivo onde adicionamos o array de informações.

Depois de ter a variável $db populada com os valores que precisamos nós utilizamos a função **list** do php, mas na versão 7.1 que nos permite trabalhar com arrays internos, fazendo a comparação de um array manipulado por nós e atribuindo valores de um array que passamos como parâmetro, ou seja, criamos um array do jeito que queremos e igualamos ele ao nosso array **$db['development']. Caso tenha dúvidas do comando list, do PHP, você pode encontrar, facilmente, conteúdos na internet.

Depois disso nós retornamos as duas informações principais do phinx que seria: **paths** e **environments**.

Em **paths** nós definimos o caminho onde ficarão nossas migrations e também nossas **seeds**, que falaremos em outro módulo. Percebam que os caminhos especificados não existem então você deve criar a pasta **db** e dentro a pasta **migrations**. Deve também criar a pasta **seeds** dentro da mesma pasta **db**.

Esta configuração serve para o phinx saber de onde carregar os arquivos.

Depois configuramos a propriedade **environment**, onde definimos a tabela padrão de migrações, onde o phinx fará o controle de versões, evitando que a mesma tabela seja criada novamente, em alguma linha de comando. Depois passamos a configuração de banco de dados padrão, porque podemos dicionar muitas outras configurações, mas caso ele não encontre nenhuma ele pegará a configuração padrão, que foi definida.

Percebam que nós estamos atribuindo os dados para a configuração **development**, utilizando as variáveis atribuídas através do comando **list**. Este comando pega os dados da variável $db que, por sua vez, carrega os valores do arquivo db.php, presente na pasta **config**. Tente entender o caminho até chegarmos nesta configuração, este é um passo muito importante. Leia com atenção.

### Executando primeiro comando do phinx

O Composer, ao instalar a biblioteca, cria uma pasta chamada **vendor**, que você pode ver em sua pasta raiz do projeto. Dentro desta pasta existe uma outra pasta chamada **bin**, onde fica os arquivos executáveis das bibliotecas, caso existam.

No caso do phinx existe um arquivo chamado **phinx** ou, se estiver utilizando Windows, **phinx.bat**. Esta é a importância do Composer, esta facilidade que ele nos proporciona, criando uma funcionalidade diferente de acordo com seu sistema operacional.

No terminal rode:

`vendor/bin/phinx` ou `vendor/bin/phinx.bat`

Este comando lhe retornará uma lista de comandos disponíveis.

Para testar se nossa configuração está funcionando, vamos criar uma nova migração. Rode o comando abaixo:

`vendor/bin/phinx create CreateCategoryCosts` ou `vendor/bin/phinx.bat create CreateCategoryCosts`

Crie nomes sugestivos para suas classes de migrações, para que seja facilmente identificada futuramente. Veja exemplos:

Criação de novas tabelas | Criação de novos campos
---------------------------------- | -----------------------------------
CreateCategoryCosts | AddNameFieldToCategoryCosts

Um padrão muito utilizado é adicionar o nome das classes no plural. Este modelo é muito utilizado por muitos outros frameworks.

A classe criada terá o mesmo nome que você definiu no comando do **phinx**. Porém existirá uma numerção gerada, de acordo com data e hora da criação, e também terá **underscore** separando. Este padrão sempre será seguido para que não exista conflitos de nomes iguais para os arquivos.

Nos próximos módulos você vai entender melhor o que esta classe será capaz de fazer. Basicamente todo seu banco de dados será resumido a uma classe, que irá rodar os comando que você, teóricamente, precisaria rodar manualmente toda vez que fosse fazer qualquer alteração. O nível de automação é muito auto e lhe trás uma facilidade muito grande.

Acreditamos que você nunca mais deixará de utilizar este conceito para suas aplicações, porque o benefício é muito grande.

Só por termos executado o comando e a classe ter sido criada, concluímos que esteja tudo correto, porém ainda testaremos a criações dos campos para confirmar o funcionamento completo da classe.