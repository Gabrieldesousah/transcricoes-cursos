# Criando resource e armazem para turmas de professor

Com a API pronta para a listagem de turmas precisamos nos preocupar com o frontend.

Como estamos trabalhando com vuex e resources precisamos dar prioridade na criação destes dois recursos antes de gerar o componente de listagem.

Não existe uma maneira correta de separar a área de aluno da área de professor, porém precisamos estruturar muito bem a aplicação para separar, de forma organizada, as duas áreas.

Mostraremos uma das formas possíveis de fazer esta divisão.

Abra o arquivo **/resources/assets/spa/js/services/resources.js**.

```js
const Teacher = {
    classInformation: Vue.resource('teacher/class_informations/{class_information}')
};

const Student = {

};


export {
    Teacher, Student
};
```

Estamos criando duas constantes por serem dois recursos que não modificados. Adicionamos as duas constantes para serem exportadas.

Quando quisermos fazer uma requisição poderemos importantar a constante **Teacher** e acessar a rota das seguintes formas:

**Teacher.classInformation.query()** ou **Teacher.classInformation.get()**

Depois de configurar a rota de acesso precisamos configurar o nosso armazem.

O Vuex permite que trabalhemos com módulos dentro de módulos, de tal forma que o código abaixo seria possível. O arquivo de exemplo é **/resources/assets/spa/js/store/store.js**.

```js
export default new Vuex.Store({
    modules: {
        auth,
        teacher: {
            modules: {
                classInformation,
                provas
            }
        }
    }
});
``` 

Não faremos exatamente desta forma, mas saiba que seria possível ter quantos módulos fossem necessários, de forma alinhada.

Primeiro crie o arquivo **/resources/assets/spa/js/store/teacher/class_information.js**. Crie as pastas que forem necessárias para que o arquivo tenha este endereço.

Depois crie e abra o arquivo **/resources/assets/spa/js/store/teacher.js**.

```js
import classInformation from './teacher/class_information';

const module = {
    namespaced: true,
    modules: {
        classInformation
    }
}

export default module;
```

O arquivo **store.js** ficará desta maneira, depois que criarmos o store **teacher.js**.

```js
import Vuex from 'vuex';
import auth from './auth';
import teacher from './teacher';

export default new Vuex.Store({
    modules: {
        auth, teacher
    }
});
```

Percebam que estamos adicionando módulo dentro de módulo. Não se preocupe com a forma que chamaremos as mutations e actions, pois mostraremos nos próximos módulos.

Adicione o código abaixo em nosso armazem **class_information.js**.

```js
const state = {
    classInformations:[],
    classInformation: null
};

const mutations = {
    setClassInformations(state, classInformations){
        state.classInformations = classInformations;
    },
    setClassInformation(state, classInformation){
        state.classInformation = classInformation;
    }
};

const actions = {
    query(context){

    },
    get(context, classInformationId){

    }
};

export default {
    namespaced: true,
    state, mutations, actions
}
```

Veja como ficou nosso armazem com state, mutations e actions.

Depois de criar este armazem chegou a hora de trabalhar com a estrutura que criamos no serviço **resource**. Para isso temos que importá-lo em nosso armazem para utilizar em nossas actions. Veja como ficaria:

```js
// Importando o serviço de resource somente a constante Teacher
import {Teacher} from '../../services/resources';

// Definindo actions
const actions = {
    query(context){
        Teacher.classInformation.query()
            .then(response => {
                context.commit('setClassInformations', response.data);
            });
    },
    get(context, classInformationId){
        Teacher.classInformation.get({class_information: classInformationId})
            .then(response => {
                context.commit('setClassInformation', response.data);
            });
    }
};
```

Vejam que estamos disparando as requisições e em casos de sucesso executamos as mutations que alimentam o nosso armazem, depois disso vamos precisar apenas listar em nossa view, porém deixaremos para testar no próximo módulo.