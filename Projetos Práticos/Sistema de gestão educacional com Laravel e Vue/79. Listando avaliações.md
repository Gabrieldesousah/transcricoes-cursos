# Listando avaliações

Com toda estrututa de teste criada precisamos criar o controller, que será capaz de gerenciar todas as consultas.

Para criar o controller rode o comando abaixo:

```sh
php artisan make:controller Api\\Teacher\\ClassTestsController --resource
```

Depois de criar o controller apague os métodos **create e edit**. Deixando somente os métodos abaixo:

```php
namespace SON\Http\Controllers\Api\Teacher;

use SON\Http\Controllers\Controller;

class ClassTestsController extends Controller
{
    public function index()
    {
        //
    }

    public function store()
    {
        //
    }

    public function update()
    {
        //
    }

    public function show()
    {
        //
    }

    public function destroy()
    {
        //
    }
}
```

Começaremos pelo método **index**, porém para que entenda a lógica do controller precisaremos primeiro criar o grupo de rotas. Abra o arquivo **/routes/api.php**.

Como as avaliações sempre serão dependentes de um ensino, precisaremos sempre passar o id do ensino para as rotas, desta forma sempre conseguiremos fixar os relacionamentos. Por este motivo criaremos um grupo de rotas separado.

```php
Route::group(['prefix' => '/class_teachings/{class_teaching}', 'as' => 'class_teaching.'], function(){
    Route::resource('class_tests', 'ClassTestsController', ['except' => ['create', 'edit']]);
});
```

Vejam que este conceito é conhecido como recurso alinhado, pois nunca será possível pesquisar avaliações de um modo geral, mas sempre informando um ensino. Por este motivo adicionamos o id do ensino como prefixo da rota, obrigando que o mesmo sempre seja passado.

Estamos passando um grupo de rotas do tipo **resource**, apontando para o controller **ClassTestsController**, e excluindo os métodos **create** e **edit**, pois se trata de uma API e não mostraremos nenhum formulário para criação ou edição de dados.

Outro fato importante a ser atentado é o fato de termos uma rota com o mesmo nome do nosso prefixo **class_teachings**, por este motivo o grupo deve estar sempre antes desta rota, para que não haja confusão entre as mesmas.

```php
// Analise seu arquivo de rotas de api e confira a sequência destas rotas
Route::group(['prefix' => '/class_teachings/{class_teaching}', 'as' => 'class_teaching.'], function(){
    Route::resource('class_tests', 'ClassTestsController', ['except' => ['create', 'edit']]);
});
Route::resource('class_informations', 'ClassInformationsController', ['only' => ['index', 'show']]);
Route::resource('class_teachings', 'ClassTeachingsController', ['only' => ['index', 'show']]);
```

Veja como ficará a rota que devemos acessar, para ter os recursos alinhados, lembrando que são exemplos:

Listar todas as avaliações do ensino 1: **/class_teachings/1/class_tests**

Listar somente uma determinada avaliação do ensino 1: **/class_teachings/1/class_tests/1**

### Método index

Como precisaremos consultar as avaliações de um determinado ensino e também passar o id de um determinado professor, temos que nos atentar a um passo de segurança. Imagine que um professor saiba o id do outro, ele pode dar um jeito de passar uma requisição com o id de outro prodessor e ter acesso as suas avaliações.

Portanto além de passar o id do ensino teremos que verificar se o id do professor logado é o mesmo id passado como parâmetro, assim teremos certeza que se trata do professor correto.

Para isso decidimos fazer um query scope, para facilicar nossa busca no método index. Portanto abra o model **/app/Models/ClassTest.php**.

```php
public function scopeByTeacher($query, $teacherId)
{
    return $query->whereHas('classTeaching', function ($query) use ($teacherId){
        $query->where('teacher_id', $teacherId);
    });
}
```

Vejam que neste query scope estamos retornando somente resultados onde o **teacher_id** for igual ao **teacherId**, que será passado como parâmetro.

Lembrando que o método **whereHas** monta um query builder que podemos utilizar depois, em nosso método index do controller.

Na verdade estamos acessando o relacionamento **classTeaching**, que está no próprio model, porém estamos adicionando uma cláusula onde somente deverão ser retornados os ensinos do professor logado. Só estamos fazendo isso de forma mais organizada e utilizando o query scope ao invés de fazer toda lógica diretamente no controller.

Voltando ao método index adicione o seguinte código:

```php
public function index(ClassTeaching $classTeaching)
{
    $results = ClassTest
        ::where('class_teaching_id', $classTeaching->id)
        ->byTeacher(\Auth::user()->userable->id)
        ->get();
    
    return $results;
}
```

Agora estamos seguros de que os resultados que teremos serão somente relacionados ao professor logado. Utilizamos o query scope passando o id do usuário logado, conforme programamos anteriormente.

Para agilizar nosso desenvolvimento, podemos criar o método **show**, que é muito parecido.

```php
public function show(ClassTeaching $classTeaching, $id)
{
    $result = ClassTest
        ::byTeacher(\Auth::user()->userable->id)
        ->findOrFail($id);

    return $result;
}
```

A lógica é muito parecida porém podemos pegar somente uma avaliação passando, como parâmetro, o id da avaliação que desejamos.

Agora para testar os resultados faça o login com o professor teste, para que o token seja válido, e abra o **Postman**. Teremos que conseguir consultar a API e ver os resultados da listagem de avaliações.

Para listar os ensinos acesse a url abaixo:

**http://localhost:8000/api/teacher/class_teachings**

Depois escolha um id e rode a url abaixo, passando o id do ensino escolhido:

**http://localhost:8000/api/teacher/class_teachings/93/class_tests**

Com este acesso teremos as 30 avaliações criadas pela nossa seeder. Escolha uma avaliação e rode o comando abaixo:

**http://localhost:8000/api/teacher/class_teachings/93/class_tests/20**

Desta forma estará acessando somente uma avaliação, de um professor que esteja logado. Lembrando que os exemplos acima foram dados gerados em nossos testes, em seu caso deverá selecionar seus próprios dados.

Não se esqueça de passar um token válido durante a requisição, adicionando o header **Authorization** com o Bearer e o token.

O método de requisição deve ser do tipo **GET**.

No próximo módulo configuraremos os dados que queremos que sejam retornados, através do método **toArray** do model **ClassTest**. Estes dados serão importantes para a criação das views.

Em outros módulos finalizaremos os outros métodos que estão faltando.