# Reflexão sobre Vuex e two way data binding

Neste módulo refletiremos a melhor maneira de se trabalhar com o vuex.

A maneira habitual seria criar uma propriedade **data**, no componente, que receberia um objeto com todos os campos do banco de dados. Depois disso era só adicionar uma diretiva **v-model** em cada campo e sair alimentando-os.

Porém desta maneira teríamos que criar uma forma de levar estes dados para os próximos passos da criação de uma avaliação, ou seja, teríamos que enviar para o componente de criação das questões e alternativas, caso contrário perderíamos as informações da avaliação.

Poderíamos trabalhar com eventos e utilizar o **dispatch** para levar de um componente para o outro, porém seria uma forma mais burocrática de se trabalhar.

Então, para facilitar o desenvolvimento e também a manutenção, vamos centralizar este processo no vuex. Por este motivo não trabalharemos com a propriedade **data** e centralizaremos em nosso armazem, pois se trata da fonte única da verdade.

Sempre que quisermos alterar algum dado teremos que acionar o armazem, que já conterá os dados que quisermos. Atualmente temos um método em **computed**, chamado **classTest**, que está iniciando este procedimento, mas ainda não estamos utilizando e vamos melhorar. Veja abaixo:

```js
computed: {
    classTest() {
        return store.state.teacher.classTest.classTest;
    },
},
```

Lembrando que temos uma arquitetura por trás do vuex, que é baseada no flux do Facebook, ou seja, para conseguir alterar um valor no armazem precisamos criar uma mutation.

Abaixo criaremos um exemplo, com apenas um campo, para que você consiga entender a forma de trabalhar com o armazem em formulários.

Abra o arquivo **/resources/assets/spa/js/components/teacher/class_test/TeacherClassTestStepData.vue**.

Primeiro altere o campo **name**, do formulário, para o código abaixo:

```html
<div class="form-group col-md-6">
    <label for="name" class="control-label">Nome</label>
    <input name="name" id="name" class="form-control" v-model="name">
    {{name}}
</div>
```

Vejam que estamos utilizando a diretiva **v-model**, para fazer o databinding dos dados, porém este dado ainda não existe. Logo abaixo criamos uma interpolação para que você consiga ver, em tempo real, as mutações alterando o armazem e mostrando o valor.

Agora criaremos os métodos computed, neste mesmo arquivo, para executar estas ações.

```js
computed: {
    classTest() {
        return store.state.teacher.classTest.classTest;
    },
    name: {
        get(){
            return this.classTest.name
        },
        set(value){
            store.commit('teacher/classTest/setName', value)
        }
    }
},
```

Vejam que a propriedade **name** possui dois métodos: get e set. Vocês já sabem que o get serve para pegar um valor e o set para atribuir um valor.

Com este conhecimento você pode ver que o get retorna o valor que busca no armazem e o set está executando a mutation **teacher/classTest/setName** e passando valor digitado no campo do formulário. Porém ainda não criamos este mutation no armazem.

Agora abra o arquivo **/resources/assets/spa/js/store/teacher/class_test.js**.

```js
// Criando mini armazem classTest com campo name
const state = {
    classTests: [],
    classTest: {
        name: ''
    },
};

// Criando mutation para alterar o estado da aplicação
const mutations = {
    setName(state, name){
        state.classTest.name = name;
    }
};
```

Com estas alterações você já pode acessar o formulário, do componente de criação, e digitar algo no campo name. Você poderá ver o vuex gravando e mostrando os dados do armazem.

A lógica é a seguinte:

1. Ao digitar algum valor no campo, a diretiva v-model executa a mutation, através do método **set**, passando o valor digitado
2. A mutation grava o valor no mini armazem classTest, no atributo **name**
3. O mini armazem dispara um evento passando o mini armazem classTest atualizado para o componente
4. A propriedade computed recebe o evento, atualiza os dados e teremos o dado sendo mostrado através da interpolação **{{name}}** e consequentemente no campo do formulário, através do v-model.

Porém se o formulário tivesse dez campos, precisaríamos criar 10 mutations e o processo começaria a ficar mais trabalhoso e não estaria arquitetado da melhor forma possível, mesmo que criasse uma estrutura somente para este processo.

Existe uma maneira mais produtiva de fazer todo este processo de uma vez só, independente da quantidade de campos existentes no formulário.

O nosso objetivo, neste módulo, era fazer você refletir como utilizar os recursos do vuex, para saber se é vantajoso ou não trabalhar campo a campo. Uma vez que se fosse apenas um, ou dois campos, poderia ser feito da maneira acima que não teríamos problema algum.

Mostraremos uma biblioteca que faz todo trabalho pesado pra gente, deixando o trabalho com formulário e vuex muito mais simples, mas queríamos que você, ao terminar de ler este módulo, ficasse ciente do trabalho que seria fazer tudo manualmente se tivéssemos muitos campos no formulário.