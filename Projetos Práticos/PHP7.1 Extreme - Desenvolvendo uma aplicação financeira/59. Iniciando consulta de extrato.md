# Iniciando consulta de extrato

Agora que tratamos as datas, vindas do formulário, podemos começar a fazer a busca no banco de dados, para finalmente finalizarmos a area de extrato e mostrar o resultado na view para o usuário.

O extrato não é algo concreto e não grava nada em banco de dados, porque depende dos dados do usuário para efetuar a busca, então não teremos um model para extrato. Teóricamente não poderíamos criar um repository para extrato, pelo fato de não tem um model associado, mas em nosso caso podemos criar este novo repository.

Com este repository efetuaremos uma busca personalizada, manipulando contas a receber e contas a pagar para geram um resultado para o usuário. Mas não precisaremos de todos os métodos presentes no **DefaultRepository**, então criaremos uma nova interface chamada **src/Repository/StatementRepositoryInterface.php**. Veja código abaixo:

```php
declare(strict_types = 1);

namespace SONFin\Repository;

interface StatementRepositoryInterface
{
    public function all(string $dateStart, string $dateEnd, int $userId): array;
}
```

Depois criamos um novo repository implementando a interface. O repository se chamará **StatementRepository.php**.

```php
namespace SONFin\Repository;

class StatementRepository implements StatementRepositoryInterface
{

    public function all(string $dateStart, string $dateEnd, int $userId): array
    {
        //select from bill_pays left join category_costs
        $billPays = BillPay::query()
            ->selectRaw('bill_pays.*, category_costs.name as category_name')
            ->leftJoin('category_costs', 'category_costs.id', '=', 'bill_pays.category_cost_id')
            ->whereBetween('date_launch', [$dateStart, $dateEnd])
            ->where('bill_pays.user_id', $userId)
            ->get();
        
        $billReceives = BillReceive::query()
            ->whereBetween('date_launch', [$dateStart, $dateEnd])
            ->where('user_id', $userId)
            ->get();
    }
}
```

Vejam que nosso método **all** é diferente dos demais, porque temos que fazer uma busca personalizada, antes de processar os dados, e enviar os dados para a view.

> Falando sobre as contas a pagar, que será atribuído a variável **$billPays**.

| Método | Descrição | 
| ------ | --------- |
| ->selectRaw() | Informamos quais campos desejamos para resultado |
| ->leftJoin() | Aplicamos um left join para filtrar os resultados por relacionamento de categorias |
| ->whereBetween() | Filtra o resultado de acordo com as datas informadas |
| ->where() | Filtra por id de usuário |
| ->get() | Pega os resultados e atribui a variável $billPays |

Estamos trabalhando com orientação a objetos de forma fluente, porque temos esta possibilidade, porém, por trás, estes métodos estão executando os comando SQL normalmente. Estes métodos foram criados para tornar a pesquisa mais tranquila.

Vejam que vamos filtrando os resultados até obter apenas o que precisamos para fazer o relatório.

> Falando sobre as contas a pagar, que será atribuído a variável **$billPays**.

Como estes dados não tem relação com categorias ele se torna mais simples. Não precisamos informar os campos que queríamos, porque pegaremos todos, e também não precisamos fazer o *left join*. Sobrando apenas o filtro por *data* e *id* de usuário.

Com estes dados basta fazermos a lógica de cálcula do estrado, que não será difícil, mas faremos no próximo módulo.