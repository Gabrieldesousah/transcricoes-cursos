# Edição de categoria de custo

Daremos continuidade ao CRUD de categorias de centro de custos, porque temos a criação de categoria funcionando e também já implementamos as melhorias necessárias.

Neste módulo nos concentraremos a edição de uma categoria.

Em primeiro lugar crie a rota no arquivo **public/index.php**. Veja o código abaixo:

```php
->get('/category-costs/{id}/edit', function(ServerRequestInterface $request) use($app){
        $view = $app->service('view.renderer');
        $id = $request->getAttribute('id');
        $category = \SONFin\Models\CategoryCost::findOrFail($id);
        return $view->render('category-costs/edit.html.twig', [
            'category' => $category
        ]);
    }, 'category-costs.edit');
```

A rota, além de ser responsável por renderizar um template, faz uma consulta no banco de dados, para saber se o id existe ou não. Existindo ela passa, para o template, os dados da categoria, como parâmetro, caso não encontre, retorna uma exception, que podemos tratar em nossa aplicação. O método responsável por este procedimento é o **findOrFail**.

Estamos renderizando um template, chamado **edit.html.twig**. Este template ainda não existe, então crie o arquivo **templates/category-costs/edit.html.twig**. Veja o conteúdo deste arquivo.

```html
{% extends 'layout.html.twig' %}

{% block content %}
    <div class="container">
        <div class="row">
            <div class="panel panel-primary">
                <div class="panel-heading">
                    <h3 class="panel-title">
                        Nova categoria de custo
                    </h3>
                </div>
                <div class="panel-body">
                    <form method="post" action="{{ route('category-costs.update', {'id': category.id}) }}">
                        <label class="control-label">Nome</label>
                        <div class="form-group">
                            <input class="form-control" type="text" placeholder="Nome" name="name" value="{{ category.name }}">
                        </div>
                        <button type="submit" class="btn btn-primary">
                            <span class="glyphicon glyphicon-floppy-disk"></span>
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
{% endblock %}
```

Percebam que estamos preenchendo o campo do formulário com o valor do nome da categoria, que passamos, por parâmetro, através do redirecionamento.

Estamos passando uma rota, que ainda não existe, para a **action** do formulário, mas logo abaixo você entenderá o motivo da criação dela. Esta rota que será responsável por fazer a atualização no banco de dados.

Precimos adicionar uma rota para o botão de edição, no template de listagem de categorias. Então adicione a seguinte modificação, ao arquivo **templates/category-costs/index.html.twig**.

```html
<a href="{{ route('category-costs.edit', {'id': category.id}) }}">
    <span class="glyphicon glyphicon-pencil"></span>
</a>
```

Reparem que o segundo parâmetro, que estamos passando para o método **route**, se trata de um array, porém, no Twig, devemos utiliza a sintaxe acima para declarar um array. Caso utilize a notação padrão do PHP você terá um erro.

Depois destes passos devemos criar a rota de edição que será do tipo **POST**. Veja a rota criada, em nosso arquivo **public/index.php**:

```php
->post('/category-costs/{id}/update', function(ServerRequestInterface $request) use($app) {
    $id = $request->getAttribute('id');
    $category = \SONFin\Models\CategoryCost::findOrFail($id);
    $data = $request->getParsedBody();
    $category->fill($data);
    $category->save();
    return $app->route('category-costs.list');
}, 'category-costs.update');
```

Vejam que estamos identificando o **id**, que será atualizado, depois estamos fazendo uma busca utilizando o método **findOrFail**, que pesquisa no banco de dados o id, caso não encontre ele retorna uma exception, para que possamos tratar em nosso código.

Depois pegamos os dado atualizado, com o método `$request->getParsedBody()`, em seguida atualizamos os valores dos atributos da classe $category, que é uma instância do model **CategoryCost**. Depois que os atributos da instância estão todos atualizados, executamos o método **save**, desta instância, que é responsável por atualizar os dados no banco.

E por último, redirecionamos para a rota de listagem.

Conforme citado acima, esta rota se chama **category-costs.update** e é responsável por atualizar a categoria no banco de dados. É ela que é passada para o atributo **action** do formulário de atualização. 

Desta forma temos criação e edição, de categorias, funcionando corretamente.