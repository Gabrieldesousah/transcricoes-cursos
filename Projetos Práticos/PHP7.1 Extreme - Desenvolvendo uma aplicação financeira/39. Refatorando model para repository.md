# Refatorando model para repository

Iniciaremos a nossa refatoração para chegar em nosso objetivo final que será utilizar nosso repositório. Desta forma simplificaremos ainda mais nosso código e estaremos trabalhando da nossa maneira e não mais dependendo do Eloquent, como estamos no momento.

Veja como ficou nosso arquivo **src/Repository/DefaultRepository.php**.

```php
class DefaultRepository implements RepositoryInterface
{
    /**
     * @var string
     */
    private $_modelClass;
    /**
     * @var Model
     */
    private $_model;


    /**
     * DefaultRepository constructor.
     *
     * @param string $modelClass
     */
    public function __construct(string $modelClass)
    {
        $this->_modelClass = $modelClass;
        $this->_model = new $modelClass;
    }

    public function all(): array
    {
        return $this->_model->all()->toArray();
    }

    public function create(array $data)
    {
        $this->_model->fill($data);
        $this->_model->save();
        return $this->_model;
    }

    public function update(int $id, array $data)
    {
        $model = $this->find($id);
        $model->fill($data);
        $model->save();
        return $model;
    }

    public function delete(int $id)
    {
        $model = $this->find($id);
        $model->delete();
    }

    public function find(int $id)
    {
        return = $this->_model->findOrFail($id)
    }
}
```

No método **all** estamos apenas retornando o método all do Eloquent.

No método **create** estamos utilizando o método **fill** para preencher todos os atributos do model e depois estamos utilizando o método **save** para criar o dado no banco. Você pode estar pensando que o método _save_ serve apenas para atualizar um dado, mas o Eloquent sabe diferenciar quando estamos criando ou atualizando algum dado. Desta forma, como não estamos fazendo nenhum busca por nenhum id, ele reconhece que se trata de um novo elemento e faz a inserção no banco.

No método **update** estamos fazendo primeiro a busca, depois o preenchimento de todos atributos do model e, por último, estamos salvando com o método **save**. Esta é diferença do método **create**, por causa da busca anterior o método _save_ reconhece que se trata de uma atualização.

No método **delete** estamos fazendo a busca de um registro por **id** e excluindo do banco de dados. Este método não precisa retornar nada.

E, por último, estamos implementando o método **find** que é utilizando em outros dois métodos: **delete** e **update**. Este método é responsável por procurar um elemento no banco, caso encontre ele retorna o elemento como um objeto, caso não encontre ele retorna uma exception.

Depois de criar este padrão de repositório chegamos a conclusão de que precisaremos criar vários tipos de repositórios parecidos, ou seja, várias instâncias desta classe. Nesta hora que podemos fazer uso de um design pattern novamente.

Quando vamos utilizar uma mesma estrutura para várias entidades podemos trabalhar com o design chamado **Factory**, que nada mais é do que uma fábrica de repositórios, pode exemplo. Falando em outras palavras podemos dizer que vamos utilizar esta fábrica para nos retornar objetos prontos de determinados repositórios.

Desta forma teremos ainda mais facilidade para trabalhar com nossa aplicação, porque quando instanciamos uma fábrica temos um objeto sendo retornado, pronto para o uso.

Sempre que encontrar algum problema, que seja difícil de ser resolvido, você pode pesquisar por algum design pattern. Existe uma grande chance de você encontrar algum padrão que resolva o seu problema, pois a muitos anos estes padrões vem sendo criados por desenvolvedores que já tiveram o mesmo problema que você.

Vamos criar o design pattern **Factory**. Crie um arquivo chamado **RepositoryFactory** dentro da pasta **src/Repository** e adicione o seguinte código:

```php
declare(strict_types=1);
namespace SONFin\Repository;

class RepositoryFactory
{
    public static function factory(string $modelClass)
    {
        return new DefaultRepository($modelClass);
    }
}
```

Vejam que a funcão desta classe é, através de um método estático, instanciar um repositório e retornar um objeto pronto do tipo **DefaultRepository**. Desta forma estamos executando um método estático que instanciará uma classe, dinamicamente, e esta classe nos disponibilizará todos os métodos que criarmos no repositório padrão.

Depois de criar nossos métodos, da classe _DefaultRepository_, e criar a factory _RepositoryFactory_, precisamos registrar o serviço em nosso container.

Registraremos em nosso arquivo **src/Plugins/DbPlugin.php**. Veja o código abaixo:

```php
use Interop\Container\ContainerInterface;
use SONFin\Repository\RepositoryFactory;

$container->add('repository.factory', new RepositoryFactory());
$container->addLazy('category-cost.repository', function (ContainerInterface $container) {
    return $container->get('repository.factory')->factory(CategoryCost::class);
});
```

Primeiro importe a classe para utilizar a classe de forma reduzida.

Adicionamos dois serviços: _repository.factory_ e _category-cost.repository_. Com estes serviços poderemos fazer toda refatoração em nosso controller.

Depois destes registros de serviçso já podemos começar a refatorar nosso controller de fato. Veja como ficou o arquivo **src/controllers/category-costs.php**.

```php
use Psr\Http\Message\ServerRequestInterface;

$app
    ->get('/category-costs', function() use($app){
        $view = $app->service('view.renderer');
        $repository = $app->service('category-cost.repository');
        $categories = $repository->all();
        return $view->render('category-costs/list.html.twig',[
            'categories' => $categories
        ]);
    }, 'category-costs.list')
    ->get('/category-costs/new', function() use($app){
        $view = $app->service('view.renderer');
        return $view->render('category-costs/create.html.twig');
    }, 'category-costs.new')
    ->post('/category-costs/store', function(ServerRequestInterface $request) use($app){
        $data = $request->getParsedBody();
        $repository = $app->service('category-cost.repository');
        $repository->create($data);
        return $app->redirect('/category-costs');
    }, 'category-costs.store')
    ->get('/category-costs/{id}/edit', function(ServerRequestInterface $request) use($app){
        $view = $app->service('view.renderer');
        $id = $request->getAttribute('id');
        $repository = $app->service('category-cost.repository');
        $category = $repository->find($id);
        return $view->render('category-costs/edit.html.twig', [
            'category' => $category
        ]);
    }, 'category-costs.edit')
    ->post('/category-costs/{id}/update', function(ServerRequestInterface $request) use($app) {
        $repository = $app->service('category-cost.repository');
        $id = $request->getAttribute('id');
        $data = $request->getParsedBody();
        $repository->update($id, $data);
        return $app->route('category-costs.list');
    }, 'category-costs.update')
    ->get('/category-costs/{id}/show', function(ServerRequestInterface $request) use($app){
        $view = $app->service('view.renderer');
        $id = $request->getAttribute('id');
        $repository = $app->service('category-cost.repository');
        $category = $repository->find($id);
        return $view->render('category-costs/show.html.twig', [
            'category' => $category
        ]);
    }, 'category-costs.show')
    ->get('/category-costs/{id}/delete', function(ServerRequestInterface $request) use($app){
        $repository = $app->service('category-cost.repository');
        $id = $request->getAttribute('id');
        $repository->delete($id);
        return $app->route('category-costs.list');
    }, 'category-costs.delete');
```

Vocês podem perceber que as rotas não foram muito modificadas, mas estamos trabalhando de forma mais organizada e orientada a serviços.

Vejam que estamos chamando o serviço **category-cost.repository** e atribuindo a variável **$repository**. Esta variável é uma instância do meu repositório padrão **DefaultRepository** e tem todos os métodos do Eloquent disponíveis para utilizar, porém estamos utilizando da forma que registramos.

O restante continua da mesma forma e temos nosso CRUD de categorias de centro de custos funcionando de forma bem mais profissional e com boas práticas de programação.