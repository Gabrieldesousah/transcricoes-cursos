# Configurando variáveis de ambiente

Chegamos a um ponto, do projeto, que precisamos começar a pensar um pouco na versão que vai rodar no servidor de produção.

Estamos falando na configuração de nossa aplicação no servidor de produção, pois até agora a única configuração que tivemos que fazer foi o acesso ao MySQL.

Configuramos os dados do banco de dados no arquivo **config/db.php**, mas esta configuração nos atendeu até o momento apenas, temos que começar a pensar em outro ambiente agora e não mais apenas o ambiente de desenvolvimento.

```php
return [
    'development' => [
        'driver' => 'mysql',
        'host' => 'localhost',
        'database' => 'son_financas',
        'username' => 'root',
        'password' => 'root',
        'charset' => 'utf8',
        'collation' => 'utf8_unicode_ci'
    ]
];
```

Nós poderíamos muito bem apenas alterar estes dados ao enviar para produção, mas estes dados acabariam entrando no controle de versão de nossa aplicação e que seria muito ruim e uma falha de segurança muito grande. Por este motivos temos que pensar em uma forma diferente de trabalhar com os ambientes desenvolvimento e produção.

Imagine que está trabalhando em um projeto em equipe e você tenha que dar um **commit** com dados sensíveis e que somente você poderia ter acesso, desta forma não teria como, porque todos os membros da equipe teriam acesso ao seu commit e, consequentemente, aos seus dados.

Em nossa aplicação trabalharemos com variáveis de ambiente, desta forma estaremos eliminando este problema.

O PHP consegue pegar as variáveis de ambiente que estão no sistema operacional do servidor, seja ele qual for. Mas você pode estar pensando que teríamos que criar estas variáveis de ambiente no sistema operacional, o que seria um trabalho muito manual e difícil de ser executado.

Nós utilizaremos uma biblioteca que fará este trabalho pra gente ao incluirmos um arquivo na raiz de nossa aplicação. Esta biblioteca se chama **phpdotenv**, que é uma biblioteca fantástica.

Apesar de ser simples, esta biblioteca nos ajudar demais quando queremos organizar nossa aplicação através de variáveis de ambiente.

Nós criaremos um arquivo **.env**, na raiz de nossa aplicação e passaremos o caminho deste arquivo nas configurações, isso fará com que a biblioteca carregue todas as variáveis de ambiente, que definirmos. Através das constantes **$\_ENV** e **$\_SERVER** podemos recuperar os valores setados.

O nosso objetivo será utilizar estas constantes, para inserir os valores, nas variáveis de banco de dados e qualquer outra que precise de segurança. Desta forma cada pessoa que for utilizar a aplicação deverá criar seu próprio arquivo **.ENV** e assim não precisam se preocupar com seus dados, basta remover este arquivo do controle de versão.

Toda vez que trabalharmos localmente teremos que criar este arquivo *.env*, mas quando subirmos nossa aplicação, utilizando *Heroku*, não precisaremos criar este arquivo, porque o Heroku já cria este arquivo pra gente.

### Instalando a biblioteca phpdotenv

`composer require vlucas/phpdotenv:2.4`

Com este comando já teremos a biblioteca instalada.

Depois de instalar a biblioteca cria, na pasta raiz da aplicação, um arquivo chamado **.env.exemple**. Veja o código deste arquivo:

```
DB_DRIVER=mysql
DB_HOST=localhost
DB_DATABASE=son_financas
DB_USERNAME=root
DB_PASSWORD=root
```

Depois de definir estes valores, com os dados corretos de seu máquina local, vamos alterar o arquivo **config/db.php**. Veja abaixo:

```php
return [
    'development' => [
        'driver' => getenv('DB_DRIVER'),
        'host' => getenv('DB_HOST'),
        'database' => getenv('DB_DATABASE'),
        'username' => getenv('DB_USERNAME'),
        'password' => getenv('DB_PASSWORD'),
        'charset' => 'utf8',
        'collation' => 'utf8_unicode_ci'
    ]
];
```

Caso alguma variável de ambiente esteja vazia, teremos o retorno *null*.

Para que possamos utilizar os valores configurados na biblioteca, temos que carregá-la no arquivo **public/index.php**.

```php
//require_once __DIR__ . '/../vendor/autoload.php';

if(file_exists(__DIR__ .'/../.env')) {
    $dotenv = new \Dotenv\Dotenv(__DIR__ . '/../');
    $dotenv->overload();
}

//require_once __DIR__ . '/../src/helpers.php';
```

Adicionamos comentários nas linha já existentes anteriormente, apenas para você saber o local em que adicionamos o código.

Veja que estamos verificando se o arquivo existe, em primeiro lugar, caso exista nós carregamos o arquivo e já aplicamos o método **overload()**, para que as variáveis sejam configuradas para a utilização na aplicação.

Existe outro arquivo que utilizamos estas variáveis, que é no arquivo **phinx.php**. Então precisaremos carregar esta leitura neste arquivo também.

```php
//require __DIR__ . '/vendor/autoload.php';

if(file_exists(__DIR__ .'/.env')) {
    $dotenv = new \Dotenv\Dotenv(__DIR__);
    $dotenv->overload();
}

//$db = include __DIR__ . '/config/db.php';
```

Agora que estamos trabalhando com variáveis de ambiente podemos alterar o nome **development**, que setamos no arquivo **config/db.php**.

```php
return [
    'default_connection' => [
        'driver' => getenv('DB_DRIVER'),
        'host' => getenv('DB_HOST'),
        'database' => getenv('DB_DATABASE'),
        'username' => getenv('DB_USERNAME'),
        'password' => getenv('DB_PASSWORD'),
        'charset' => 'utf8',
        'collation' => 'utf8_unicode_ci'
    ]
];
```

Colocaremos o nome de **default_connection**, porque a configuração não depende mais deste arquivo, mas sim do **.env**. Portanto este arquivo serve tanto para produção quanto para desenvolvimento.

Teremos que alterar também no arquivo **phinx.php**.

```php
list(
    'driver' => $adapter,
    'host' => $host,
    'database' => $name,
    'username' => $user,
    'password' => $pass,
    'charset' => $charset,
    'collation' => $collation
    ) = $db['default_connection'];
return [
    'paths' => [
        'migrations' => [
            __DIR__ . '/db/migrations'
        ],
        'seeds' => [
            __DIR__ . '/db/seeds'
        ]
    ],
    'environments' => [
        'default_migration_table' => 'migrations',
        'default_database' => 'default_connection',
        'default_connection' => [
            'adapter' => $adapter,
            'host' => $host,
            'name' => $name,
            'user' => $user,
            'pass' => $pass,
            'charset' => $charset,
            'collation' => $collation
        ]
    ]
];
```

Outro local que precisamos alterar é no arquivo **src/Plugins/DbPlugin.php**.

```php
//$capsule = new Capsule();
//$config = include __DIR__ . '/../../config/db.php';
$capsule->addConnection($config['default_connection']);
//$capsule->bootEloquent();
```

Não se esqueça de remover os arquivos **.env.example** e **.env** do controle de versão, caso esteja utilizando o git. Também não esqueça de criar um arquivo chamado **.env**, lembrando que o arquivo **.env.example** servirá apenas de lembrete de quais variáveis devem ser setadas no arquivo *.env*. Os valores serão carregados do env.

### Testando aplicação com variáveis de ambiente

Caso queira testar, no terminal, você pode adicionar no arquivo **public/index.php** o seguinte código:

```php
if(file_exists(__DIR__ .'/../.env')) {
    $dotenv = new \Dotenv\Dotenv(__DIR__ . '/../');
    $dotenv->overload();
}

echo getenv('DB_DRIVER');
```

Depois execute no terminal o seguinte comando:

`php public/index.php`

Desta forma você terá o valor, setado na variável de ambiente, impresso. Você pode testar os valores que quiser, basta acrescentar no arquivo index.php.

***

Agora que já fizemos todas as alterações necessárias, teremos que fazer o teste e ver se a aplicação continua funcionando corretamente.

Suba a aplicação com o servidor embutido do PHP, caso já estivesse sendo executada, destrua e suba novamente. Desta forma as variáveis estarão fazendo parte da aplicação, caso contrário o servidor ainda não as reconhecerá.

Depois de subir o servidor, basta navegar entre as rotas de nossa aplicação e ver se está tudo funcionando corretamente.

Faça testes de cadastro de categorias, contas a pagar e a receber, depois teste o extrato e o gráfico.