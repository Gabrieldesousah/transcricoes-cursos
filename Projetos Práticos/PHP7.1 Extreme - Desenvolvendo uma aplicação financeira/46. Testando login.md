# Testando login

Neste módulo testaremos o nosso login, na prática, para ver se realmente está tudo funcionando.

O primeiro arquivo que editaremos será o **public/controllers/auth.php**.

```php
use Psr\Http\Message\ServerRequestInterface;

$app
    ->get('/login', function(ServerRequestInterface $request) use($app){
        $view = $app->service('view.renderer');;
        return $view->render('auth/login.html.twig');
    }, 'auth.show_login_form')
    ->post(
        '/login', function (ServerRequestInterface $request) use ($app) {
        $view = $app->service('view.renderer');
        $auth = $app->service('auth');
        $data = $request->getParsedBody();
        $result = $auth->login($data);
        if(!$result) {
            return $view->render('auth/login.html.twig');
        }
        return $app->route('category-costs.list');
    }, 'auth.login');
```

Primeiro utilizamos o serviço de renderização de template, porque caso o login não seja efetuado, nós renderizaremos o template de login novamente.

Atribuímos à variável **$auth** o serviço de autenticação, depois pegamos os dados, vindos do formulário, e, por último, chamamos o método **login**, passando os dados.

Em nosso caso, renderizamos a página de login caso não seja concluído, caso contrário o usuário é direcionado para a listagem de categorias.

Depois de fazer a alteração acima, você deve testar o login.

### Corrigindo formulário

```html
<!-- templates/auth/login.html.twig -->
<div class="form-group">
    <label class="control-label">Password</label>
    <input class="form-control" type="password" placeholder="Senha" name="password">
</div>
<!-- templates/users/_form.html.twig -->
{% if user.id is null %}
<div class="form-group">
    <label class="control-label">Password</label>
    <input class="form-control" type="text" placeholder="Senha" name="password">
</div>
{% endif %}
```

Como estávamos fazendo testes, não alteramos o tipo do campo de senha e estava como **text**. Apenas alteramos para o tipo **password** para mantermos o padrão de seguraça.

Se analisarmos o arquivo **src/Auth/Auth.php**, onde se encontra o método de login, podemos ver que implementamos tudo com apenas duas linhas:

```php
public function login(array $credentials): bool
{
    list('email' => $email, 'password' => $password) = $credentials;
    return $this->jasnyAuth->login($email, $password) !== null;
}
```

Mas tudo isso se deu porque soubemos implementar uma biblioteca de terceiros para trabalhar em nosso favor.

Agora que temos nosso serviço de login funcionando, continuaremos desenvolvendo os outro métodos necessários: **check** e **logout**.

Antes de começarmos a desenvolver é importante falarmos que o Jasny grava os dados de usuário em uma sessão do PHP. Neste caso a sessão se trata de um arquivo que é criado e fica no servidor da aplicação.

Temos que ativar este serviço de sessão para que a gravação aconteça e, até o momento, ainda não ativamos. Então criaremos um método, na classe Auth, para fazer esta ativação. Faça as seguintes alterações na classe **src/Auth/Auth.php**:

```php
// Chamando o método sessionStart() no construtor
public function __construct(JasnyAuth $jasnyAuth)
{
    $this->jasnyAuth = $jasnyAuth;
    $this->sessionStart();
}

// Criando o método sessionStart() ao final da classe
protected function sessionStart()
{
    if (session_status() == PHP_SESSION_NONE) {
        session_start();
    }
}
```

Esta adaptação faz com que tenhamos certeza de que a sessão foi criada ao início de toda aplicação. Nós chamamos o método no construtor e este método verifica se a sessão existe, através da constante **PHP_SESSION_NONE**, caso exista o método não faz nada, mas se não existir ele criará a sessão pra gente.

Depois desta implementação e ciente de como funciona a sessão, vamos criar o método check. Este método retorna os dados do usário, gravados na sessão, caso o usuário esteja logado.

```php
// Criando método check no arquivo src/Auth/Auth.php
public function check(): bool
{
    return $this->jasnyAuth->user() !== null;
}
```

Depois que implementar este método nós precisaremos utilizar em nossos templates.

O menu não deve aparecer caso o usuário não esteja logado, então utilizaremos este método para informar nossas views se o usuário está logado ou não.

Nós poderíamos passas estes dados para cada view através de parâmetros, mas nosso desenvolvimento ficaria muito chato e cansativo. Temos uma forma mais simples de passar esta informação de forma global para todas as views, através do plugin de views.

Para gerenciar todas as variáveis globais que quisermos passar para nossas views, crie uma pasta, dentro da pasta **src/View**, chamada **Twig**. Dentro desta pasta cria uma classe chamada **TwigGlobals**. Veja o conteúdo deste arquivo:

```php
namespace SONFin\View\Twig;
use SONFin\Auth\AuthInterface;

class TwigGlobals extends \Twig_Extension implements \Twig_Extension_GlobalsInterface
{
    /**
     * @var AuthInterface
     */
    private $auth;

    /**
     * TwigGlobals constructor.
     */
    public function __construct(AuthInterface $auth)
    {
        $this->auth = $auth;
    }

    public function getGlobals()
    {
        return [
            'Auth' => $this->auth
        ];
    }
}
```

Estamos extendendo uma classe chamada **Twig\_Extension** e implementando uma interface **Twig\_Extension\_GlobalsInterface**. Depois passamos, no construtor, uma instância de auth.

No método **getGlobals** retornamos o nome da variável global seguido do valor que a variável conterá, ou seja, na variável global **auth** terá todos os dados do usuário, que vem de **$this->auth**.

Depois de criar a extensão para o Twig, precisamos conectá-la ao nosso plugin. Veja a implementação no arquivo **src/Plugins/ViewPlugin.php**:

```php
use SONFin\View\Twig\TwigGlobals;

$auth = $container->get('auth');

//$generator = $container->get('routing.generator');
$twig->addExtension(new TwigGlobals($auth));
```

A linha comentada já existia em nosso arquivo, comentamos para que não se confunda na hora de fazer a alteração no arquivo.

Desta forma, toda vez que um template for acessado teremos acesso as variáveis globais que determinarmos, podendo utilizar da maneira que quisermos.

A primeira utilização será no template principal, onde se encontra o menu de nossa aplicação. Veja a aplicação no arquivo **templates/layout.html.twig**:

```html
{% if Auth.check() %}
<nav class="navbar navbar-default navbar-inverse">
    <div class="container">
        <div class="navbar-header">

            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
                    data-target="#app-navbar-collapse">
                <span class="sr-only">Toggle Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <a class="navbar-brand" href="#">
                SON Finanças
            </a>
        </div>

        <div class="collapse navbar-collapse" id="app-navbar-collapse">
            <ul class="nav navbar-nav">
            </ul>

            <ul class="nav navbar-nav navbar-right">
                <li><a>Olá Usuário</a></li>
                <li><a href="#">Logout</a></li>
            </ul>
        </div>
    </div>
</nav>
{% endif %}
```

Como nós definimos a variável global **Auth** estamos testando se o método **check** retorna os dados de usuário, que foram gravados na sessão, ou se retorna false.

Como nós tínhamos feito o teste de login antes de ativarmos o controle por sessão, o menu deverá subir assim que você atualizar sua aplicação no browser, mas depois que você efetuar o login novamente o menu deverá aparecer, uma vez que os dados, desta vez, serão gravados.

Caso queira conferir os dados da sessão, que são gravados em cookies, acesse o *developer tools*, do seu navegador, e vá até a aba **Application**. Estamos falando do navegador Chrome, no Firefox você poderá encontrar com o nome de **Armazenamento**. Caso você apague o valor do cookie você verá que o menu volta a sumir e somente depois de um novo login aparecerá novamente.