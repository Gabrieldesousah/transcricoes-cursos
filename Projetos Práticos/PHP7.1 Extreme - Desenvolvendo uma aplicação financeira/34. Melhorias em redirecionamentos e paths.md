# Melhorias em redirecionamentos e paths

No módulo passado conseguimos inserir uma nova categoria de centro de custo no banco de dados, mas podemos fazer algumas melhorias, tanto em código quanto em performance.

A primeiro melhoria será no redirecionamento, que aplicamos no módulo anterior. Vamos transferir a responsabilidade para nossa classe **Application**.

Abra seu arquivo **src/Application.php** e adicione o código abaixo:

```php
use Zend\Diactoros\Response\RedirectResponse;

public function redirect($path)
{
    return new RedirectResponse($path);
}
```

Esta foi a implementação de um método redirect, em nossa classe Application. Desta forma podemos fazer um redirect para qualquer **path**, basta aplicar o método passando o endereço, como parâmetro.

Depois de criar o método redirect vamos aplicar em nossa rota. Altere o arquivo **public/index.php**.

```php
->post('/category-costs/store', function(ServerRequestInterface $request) use($app){
    $data = $request->getParsedBody();
    SONFin\Models\CategoryCost::create($data);
    return $app->redirect('/category-costs');
});
```

Reparem que a diferença está no uso da instância **$app**, na função, e estamos utilizando o método redirect passando o path. Não modificou o modo de execução, mas agora temos um código mais limpo e organizado.

A segunda melhoria será relacionada as rotas, que utilizando no nossos templates do Twig. Esta melhoria é muito importante em grandes projetos. Imagine que nossa aplicação financeira comece a ser mantida por uma equipe e, por um acaso, este equipe precise alterar a estrutura de pastas. Isso faria com que a manutenção ficasse muito grande e cansativa, porque teríam que alterar todas as rotas, colocando os novos caminhos.

A alteração que faremos evita que isso seja um problema, porque trabalharemos com nomeação de rotas. Desta forma, quando utilizamos o nome da rota, não importa o caminho dela, porque o sistema acessara de qualquer maneira. Isso significa que a equipe pode alterar a estrutura de pastas quantas vezes forem necessárias que a aplicação continuará funcionando sem quebrar o funcionamento.

Quando estávamos criando o plugin de rotas, no arquivo **src/Plugins/RoutePlugin.php**, nós adicionamos um serviço chamado **routing.generator**. Chegou a hora de utilizar este serviço. Este generator que será responsável por criar nossas rotas a partir de um nome.

Porém nós teremos que utilizar este recurso no Twig. Desta forma teremos que registrar uma função em nossa template engine. Este será nosso primeiro passo, altere o arquivo **src/Plugins/ViewPlugin.php**. Veja código abaixo:

```php
class ViewPlugin implements PluginInterface
{

    public function register(ServiceContainerInterface $container)
    {
        $container->addLazy('twig', function (ContainerInterface $container) {
            $loader = new \Twig_Loader_Filesystem(__DIR__ . '/../../templates');
            $twig = new \Twig_Environment($loader);

            $generator = $container->get('routing.generator');
            $twig->addFunction(new \Twig_SimpleFunction('route',
                function (string $name, array $params = []) use($generator){
                    return $generator->generate($name, $params);
                }));
            return $twig;
        });

        $container->addLazy('view.renderer', function (ContainerInterface $container) {
            $twigEnviroment = $container->get('twig');
            return new ViewRenderer($twigEnviroment);
        });

    }
}
```

Mostramos a classe inteira para que pudesse visualizar o contexto e o posicionamento do código que adicionarmos, mas se atente apenas ao código adicionado. Veja abaixo:

```php
$generator = $container->get('routing.generator');
$twig->addFunction(new \Twig_SimpleFunction('route',
    function (string $name, array $params = []) use($generator){
        return $generator->generate($name, $params);
    }));
```

Estamo pegando o serviço **routing.generator**, de nosso container, e registrando uma função simples em nosso template engine. Percebam que estamos utilizando métodos do próprio Twig para registrar esta função, onde passamos o nome e a lógica da função.

Criamos uma função com o nome **route** e uma lógica que recebe nome e parâmetros. Esta função retorna um path de acordo com o nome e os parâmtros passados.

Agora que criamos esta função vamos utilizar para melhoria de nossa aplicação.

Abra o arquivo **public/index.php** para adicionamos um nome a uma rota. Começaremos pela rota de adição de uma nova categoria.

```php
->get('/category-costs/new', function() use($app){
    $view = $app->service('view.renderer');
    return $view->render('category-costs/create.html.twig');
}, 'category-costs.new')
```

Adicionamos o terceiro parâmetro para a função **get**, que é o nome da rota. Este parâmetro não é obrigatório, por este motivo não estávamos utilizando. O nome registrado foi **category-costs.new**.

Agora que já passamos o nome para a rota, vamos utilizar a função **route** e passar o nome da rota para vocês entenderem o uso. Abra a view **templates/category-costs/list.html.twig**. Veja o código:

```html
<div class="row">
    <div class="col-md-12">
        <a href="{{ route('category-costs.new') }}" class="btn btn-default">
            <span class="glyphicon glyphicon-plus"></span>
        </a>
    </div>
</div>
```

Percebam que aplicamos a função route, que retorna uma rota de acordo com o nome. Salve sua aplicação e vá até o botão de adicionar para testar. Clique no botão, você deverá ser redirecionado para a página de criação.

Vamos adicionar nome para a rota de criação também. Então no arquivo **public/index.php** vamos nomear a rota do tipo **post**. Veja código:

```php
->post('/category-costs/store', function(ServerRequestInterface $request) use($app){
    $data = $request->getParsedBody();
    SONFin\Models\CategoryCost::create($data);
    return $app->redirect('/category-costs');
}, 'category-costs.store');
```

Nomeada a rota, vamos aplicar em nosso formulário de criação, onde temos informamos o endereço para a **action**. Veja código abaixo, referênte ao arquivo **templates/category-costs/create.html.twig**.

```html
<form method="post" action="{{ route('category-costs.store') }}">
    <label class="control-label">Nome</label>
    <div class="form-group">
        <input class="form-control" type="text" placeholder="Nome" name="name">
    </div>
    <button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-floppy-disk"></span>
    </button>
</form>
```

Desta forma já temos nossa criação de dados utilizando o nome da rota.

Falta ainda nomear a rota de listagem. Veja como ficou o arquivo **public/index.php**.

```php
->get('/category-costs', function() use($app){
    $meuModel = new CategoryCost();
    $categories = $meuModel->all();
    $view = $app->service('view.renderer');
    return $view->render('category-costs/list.html.twig',[
        'categories' => $categories
    ]);
}, 'category-costs.list')
```

Depois de renomear esta rota de listagem, podemos deixar nossa aplicação ainda melhor e criar uma função de geração de rotas em nossa classe **src/Application.php**, porque quando criamos uma categoria temos um redirecionamento e neste metodo ainda estamos passando o path e não o nome da rota.

Para isso vamos criar este método na classe application.php. Veja a implementação do método:

```php
public function route(string $name, array $params = [])
{
    $generator = $this->service('routing.generator');
    $path = $generator->generate($name, $params);
    return $this->redirect($path);
}
```

Vejam que o método route usa o serviço **generator** e cria, automaticamente, o path, de acordo com nome e parâmetros da rota, e depois este método já chama o método redirect para nós.

Então precisamos mudar a forma de redirecionar após o cadastramento da nova categoria. Veja como ficou:

```php
->post('/category-costs/store', function(ServerRequestInterface $request) use($app){
    $data = $request->getParsedBody();
    SONFin\Models\CategoryCost::create($data);
    return $app->route('category-costs.list');
}, 'category-costs.store');
```

Desta forma ficou ainda melhor nossa aplicação e tudo de forma dinâmica. De acorco com o nome das rotas temos os paths automaticamente, nos possibilitando modificar estruturas e refatorar nossa aplicação sem precisar ter dor de cabeça para ficar modificando os caminhos na aplicação inteira.

Temos exatamente as mesmas funcionalidades, mas agora trabalhando de uma forma muito melhor e sustentável.

Faça as alterações e leia quantas vezes forem necessárias para que entenda este conceito.