# Implementando login e senha criptografada

No módulo passado fizemos o primeiro passo de integração da biblioteca Jasny. Como já falamos, esta biblioteca que fará todo trabalho mais pesado de autenticação para nós.

Criamos uma classe que extende a classe abstrada da biblioteca e também falamos que tivemos que implementar alguns métodos.

Vendo os métodos *fetchUserById* e *fetchUserByUsername* podemos ver que ele pode retornar dois tipos de dados: *user* ou *null*. O problema é que este **user**, que devemos retornar, não é da nossa aplicação, é um user da própria biblioteca e é sobre isso que iremos falar.

Teremos então que implementar a interface da biblioteca em nosso modelo, para fazer a integração completa e poder trabalhar da forma correta, seguindo a documentação. Veja a modificação no model **src/Models/User.php**:

```php
declare(strict_types=1);

namespace SONFin\Models;

use Illuminate\Database\Eloquent\Model;
use Jasny\Auth\User as JasnyUser;

class User extends Model implements JasnyUser
{
    //Mass Assignment
    protected $fillable = [
        'first_name',
        'last_name',
        'email',
        'password'
    ];

    /**
     * Get user id
     *
     * @return int|string
     */
    public function getId():int
    {
        return (int)$this->id;
    }

    /**
     * Get user's username
     *
     * @return string
     */
    public function getUsername():string
    {
        return $this->email;
    }

    /**
     * Get user's hashed password
     *
     * @return string
     */
    public function getHashedPassword():string
    {
        return $this->password;
    }

    /**
     * Event called on login.
     *
     * @return boolean  false cancels the login
     */
    public function onLogin()
    {
        // TODO: Implement onLogin() method.
    }

    /**
     * Event called on logout.
     *
     * @return void
     */
    public function onLogout()
    {
        // TODO: Implement onLogout() method.
    }
}
```

Vejam que implementamos a interface, criamos os métodos e informamos como eles devem atuar em nossa aplicação. Os dois últimos estão em branco e podemos deixar por enquanto.

Agora pegaremos o serviço **JasnyAuth** e utilizar dentro de serviço **Auth** principal de nossa aplicação. Para isso vá até o arquivo **src/Plugins/AuthPlugin.php** e faça as seguinte alterações:

```php
declare(strict_types=1);

namespace SONFin\Plugins;


use Interop\Container\ContainerInterface;
use SONFin\Auth\Auth;
use SONFin\Auth\JasnyAuth;
use SONFin\ServiceContainerInterface;

class AuthPlugin implements PluginInterface
{

    public function register(ServiceContainerInterface $container)
    {
        $container->addLazy('jasny.auth', function (ContainerInterface $container){
            return new JasnyAuth($container->get('user.repository'));
        });
        $container->addLazy('auth', function (ContainerInterface $container) {
            return new Auth($container->get('jasny.auth'));
        });
    }
}
```

Estamos registrando um novo serviço do tipo **Lazy** que instancia a classe JasnyAuth e no segundo serviço executamos esta classe passando para a classe **Auth** uma instância do classe **JasnyAuth**. Desta forma estamos injetando um serviço dentro do outro.

Depois podemos voltar a classe **src/Auth/Auth.php** e fazer as seguintes alterações:

```php
namespace SONFin\Auth;


class Auth implements AuthInterface
{
    /**
     * @var JasnyAuth
     */
    private $jasnyAuth;

    public function __construct(JasnyAuth $jasnyAuth)
    {
        $this->jasnyAuth = $jasnyAuth;
    }

    public function login(array $credentials): bool
    {
        list('email' => $email, 'password' => $password) = $credentials;
        return $this->jasnyAuth->login($email, $password) !== null;
    }

    public function check(): bool
    {
        // TODO: Implement check() method.
    }

    public function logout(): void
    {
        // TODO: Implement logout() method.
    }
}
```

Como estamos instanciando a classe Auth passando um parâmetro do tipo **JasnyAuth**, nós implementando o método construct para setar o serviço no atributo.

Depois partimos para o método login, onde passamos um array com as credenciais. Vocês pode ver que estamos setando valores para as variáveis **$email** e **$password** utilizando a função **list** do PHP.

O próximo passo do método login é retornar o login, porém o método **login** do **jasnyAuth** trabalha com a senha criptografada e nós ainda não criptografamos. Estamos trabalhando com senhas comuns por enquanto.

Teremos que fazer algumas alterações antes de fazer o teste de login. Criamos um novo método, chamado **hashPassword**, no arquivo **src/Auth/AuthInterface.php**, veja abaixo:

```php
declare(strict_types = 1);

namespace SONFin\Auth;


interface AuthInterface
{
    public function login(array $credentials): bool;

    public function check(): bool;

    public function logout(): void;
    
    public function hashPassword(string $password): string;
}
```

Agora precisamos implementar o método **hashPassword** logo abaixo do método **logout** em nossa classe **Auth**.

```php
public function hashPassword(string $password): string
{
    return $this->jasnyAuth->hashPassword($password);
}
```

### Aplicando serviço na seeder

Dentro da pasta **db** crie um arquivo chamado **bootstrap**, para conseguirmos trabalhar com a nossa classe **Application** e com alguns serviços. Desta forma poderemos utilizar os serviços na seeder e não somente na aplicação. Abaixo o conteúdo do arquivo *bootstrap.php*:

```php
use SONFin\Application;
use SONFin\Plugins\AuthPlugin;
use SONFin\Plugins\DbPlugin;
use SONFin\ServiceContainer;

$serviceContainer = new ServiceContainer();
$app = new Application($serviceContainer);

$app->plugin(new DbPlugin());
$app->plugin(new AuthPlugin());
return $app;
```

Considerando que a biblioteca **phinx** já faz o carregamento do autoload, nós não precisamos nos preocupar com o autoload neste arquivo.

Agora precisamos apenas abrir o arquivo **db/seeds/UsersSeeder.php** e alterar a forma de rodar. Veja como ficou:

```php
use Phinx\Seed\AbstractSeed;

class UsersSeeder extends AbstractSeed
{
    /**
     * Run Method.
     *
     * Write your database seeder using this method.
     *
     * More information on writing seeders is available here:
     * http://docs.phinx.org/en/latest/seeding.html
     */
    public function run()
    {
        /** @var \SONFin\Application $app */
        $app = require __DIR__ . '/../bootstrap.php';
        $auth = $app->service('auth');

        $faker = \Faker\Factory::create('pt_BR');
        $users = $this->table('users');
        $users->insert([
            'first_name' => $faker->firstName,
            'last_name' => $faker->lastName,
            'email' => 'admin@user.com',
            'password' => $auth->hashPassword('123456'),
            'created_at' => date('Y-m-d H:i:s'),
            'updated_at' => date('Y-m-d H:i:s')
        ])->save();
        $data = [];
        foreach (range(1, 3) as $value) {
            $data[] = [
                'first_name' => $faker->firstName,
                'last_name' => $faker->lastName,
                'email' => $faker->unique()->email,
                'password' => $auth->hashPassword('123456'),
                'created_at' => date('Y-m-d H:i:s'),
                'updated_at' => date('Y-m-d H:i:s')
            ];
        }
        $users->insert($data)->save();
    }
}
```

Agora basta rodar novamente as seeders no terminal para que as senhas sejam criptografadas. Desta forma poderemos testar nosso serviço de autenticação. Lembrando que fizemos isso porque o método **login**, da biblioteca Jasny, trabalha com password criptografado.

Rode o comando: `php migrate-seed.php`

Depois de rodar este comando você pode acessar novamente o banco de dados para ver as senhas todas criptografadas. A criptografia utilizada é o bcript, que o PHP utiliza a um bom tempo.

A partir de agora podemos testar nosso login, mas deixaremos para o próximo módulo.