# Adicionando usuários às categorias

Agora que já protegemos as rotas e somente usuários logados podem acessar a área administrativa trabalharemos com foco nas finanças pessoais, que o usuário gerenciará.

Na atual aplicação todas as categorias estão sendo mostradas para todos os usuários, porque ainda não fizemos a relação de cada categoria criada com o usuário criador, ou seja, se um usuário cria uma categoria, esta categoria é vista por todos usuários.

Relacionaremos todas as tabelas com o ID de cada usuário, assim sempre teremos somente as contas a pagar de um usuário, as contas a receber, as categorias de centros de custos e etc.

Agora chegou a hora de ver a importância de trabalhar com migrações, ou seja, não editaremos as migrações existentes, para adicionar estes relacionamentos, criaremos uma nova migração. Desta forma estamos versionando nosso banco de dados.

Então utilizaremos o terminal para rodar o comando de criação de uma nova migração.

Lembre-se, sempre, de criar nomes sugestivos para suas migrações, para que saiba, facilmente, qual o papel de cada uma delas.

`vendor/bin/phinx create AddUserToCategoryCosts` ou `vendor\bin\phinx.bat create AddUserToCategoryCosts`

Veja o conteúdo da nova migração:

```php
use Phinx\Migration\AbstractMigration;

class AddUserToCategoryCosts extends AbstractMigration
{
    public function up()
    {
        $this->table('category_costs')
            ->addColumn('user_id', 'integer')
            ->addForeignKey('user_id', 'users', 'id')
            ->save();
    }

    public function down()
    {
        $this->table('category_costs')
            ->dropForeignKey('user_id')
            ->removeColumn('user_id');
    }
}
```

Depois de criar o relacionamento nas tabelas, através da migração, temos que lembrar de alterar dois arquivos para que possamos rodar novamente a estruturação do nosso banco de dados com conteúdos testes.

Primeiro edito o model **src/Models/CategoryCost.php**. Veja o conteúdo:

```php
namespace SONFin\Models;

use Illuminate\Database\Eloquent\Model;

class CategoryCost extends Model
{
    // Mass Assignment
    protected $fillable = [
        "name",
        "user_id"
    ];
}
```

E também temos que alterar nossa Seeder, para que o conteúdo seja criado corretamente. Altere **db/seeds/CategoryCostsSeeder.php**:

```php
use Phinx\Seed\AbstractSeed;

class CategoryCostsSeeder extends AbstractSeed
{
    /**
     * Run Method.
     *
     * Write your database seeder using this method.
     *
     * More information on writing seeders is available here:
     * http://docs.phinx.org/en/latest/seeding.html
     */
    public function run()
    {
        $faker = \Faker\Factory::create('pt_BR');
        $categoryCosts = $this->table('category_costs');
        $data = [];
        foreach (range(1, 20) as $value) {
            $data[] = [
                'name' => $faker->name,
                'user_id' => rand(1,4),
                'created_at' => date('Y-m-d H:i:s'),
                'updated_at' => date('Y-m-d H:i:s')
            ];
        }
        $categoryCosts->insert($data)->save();
    }
}
```

Depois de tudo alterado, temos que nos atentar a um detalhe, antes de executar a seeder. Como a categoria terá sempre um usuário relacionado, os usuário devem ser criados antes da geração das categorias para não ocorrer um erro de MySQL.

Teremos que alterar a order, manualmente, no arquivo **migrate-seed.php**, que fica na raiz de nossa aplicação. Veja o código:

```php
exec(__DIR__ . '/vendor/bin/phinx rollback -t=0');
exec(__DIR__ . '/vendor/bin/phinx migrate');
exec(__DIR__ . '/vendor/bin/phinx seed:run -s UsersSeeder');
exec(__DIR__ . '/vendor/bin/phinx seed:run -s CategoryCostsSeeder');
```

Desta forma estamos executando as seeders, separadamente, na ordem que quisermos.

Depois de executar o arquivo *migrate-seed* acesse seu banco de dados para conferir as alterações que foram feitas e os campos criados com sucesso.

Ao verificar o funcionamento correto, chegamos a conclusão de que nomes próprios, no lugar de categorias reais, não estavam ilustrando, da melhor forma, nossa aplicação, embora funcionem para testes. Então modificaremos, os dados de testes, para exemplos que possam ser reais em nossa aplicação.

Para este procedimento alteraremos o arquivo **db/seeds/CategoryCostsSeeder.php**. Vejam as alterações:

```php
use Phinx\Seed\AbstractSeed;

class CategoryCostsSeeder extends AbstractSeed
{
    const NAMES = [
        'Telefone',
        'Água',
        'Escola',
        'Cartão',
        'LUZ',
        'IPVA',
        'Imposto de Renda',
        'Gasolina',
        'Vestuário',
        'Entretenimento',
        'Reparos'
    ];

    /**
     * Run Method.
     *
     * Write your database seeder using this method.
     *
     * More information on writing seeders is available here:
     * http://docs.phinx.org/en/latest/seeding.html
     */
    public function run()
    {
        $faker = \Faker\Factory::create('pt_BR');
        $faker->addProvider($this);
        $categoryCosts = $this->table('category_costs');
        $data = [];
        foreach (range(1, 20) as $value) {
            $data[] = [
                'name' => $faker->categoryName(),
                'user_id' => rand(1,4),
                'created_at' => date('Y-m-d H:i:s'),
                'updated_at' => date('Y-m-d H:i:s')
            ];
        }
        $categoryCosts->insert($data)->save();
    }

    public function categoryName()
    {
        return \Faker\Provider\Base::randomElement(self::NAMES);
    }
}

```

Primeiro criamos uma constante, com alguns exemplos de categorias reais, depois criamos a função abaixo:

```php
public function categoryName()
{
    return \Faker\Provider\Base::randomElement(self::NAMES);
}
```

Esta função retorna sempre um valor aleatório de nossa constante.

Para utiliza a função adicionamos um novo **provider**, no faker, passando a própria instância como parâmetro. Desta forma estamos tendo acesso ao método que criamos, para que possamos executá-lo. Depois apenas chamamos o método.

Adicionando provider:

`$faker->addProvider($this);`

Chamando função:

`'name' => $faker->categoryName()`

Desta forma estamos populando nossos dados de teste com categorias reais. Desta forma ainda poderá ter dados repetidos, mas não irá interferir em nossos testes, caso queira menos repetições você pode criar uma programação ou aumentar o número de categorias em nossa constante.

Depois de tudo feito execute novamente o arquivo *migrate-seed* e depois analise os novos valores de categorias.

Podemos continuar com o nosso desenvolvimento, pois estamos com todos os dados ligados e com exemplos mais reais.