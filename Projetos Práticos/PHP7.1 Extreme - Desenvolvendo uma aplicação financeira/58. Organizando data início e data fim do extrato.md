# Organizando data início e data fim do extrato

Agora que já temos a estrutura pronta, precisamos começar a tratar as datas informadas, pelo usuário, em nosso controller.

Veja como ficará nosso controller **src/controllers/statements.php**:

```php
use Psr\Http\Message\ServerRequestInterface;

$app
    ->get('/statements', function(ServerRequestInterface $request) use($app){
        $view = $app->service('view.renderer');
        $data = $request->getQueryParams();
        
        $dateStart = $data['date_start'] ?? (new \DateTime())->modify('-1 month');
        $dateStart = $dateStart instanceof \DateTime ? $dateStart->format('Y-m-d')
            : \DateTime::createFromFormat('d/m/Y', $dateStart)->format('Y-m-d');
        
        $dateEnd = $data['date_end'] ?? new \DateTime();
        $dateEnd = $dateEnd instanceof \DateTime ? $dateEnd->format('Y-m-d')
            : \DateTime::createFromFormat('d/m/Y', $dateEnd)->format('Y-m-d');

        return $view->render('statements.html.twig');
    }, 'statements.list');
```

Vejam que primeiro estamos pegando os dados enviados, pelo método **get**, do formulário, através do método **getQueryParams**.

Depois nós utilizamos um recurso do PHP7, para diminuir o código, sem precisar ficar pegando as constantes do PHP como **$\_GET['date_start']**, por exemplo, e ficar fazendo vários testes para saber se o valor existe ou não.

Então resumindo estamos atribuindo o valor escolhido pelo usuário, caso ele exista, caso contrário estamos atribuindo uma instância **DateTime**. Desta forma garantimos que sempre haverá um valor, do tipo data, na variável **$dateStart** e também em **$dateEnd**.

```php
$dateStart = $data['date_start'] ?? (new \DateTime())->modify('-1 month');

$dateEnd = $data['date_end'] ?? new \DateTime();
```

Depois verificando se a variável é uma instância de DateTime, caso seja, nós já formatamos o valor, da maneira que queremos, caso não seja, criamos a data atual no formato exigido para pesquisarmos no banco de dados.

Então garantimos que haverá sempre uma data, no formato correto, para pesquisa em banco de dados, evitando erros de formato.

```php
$dateStart = $dateStart instanceof \DateTime ? $dateStart->format('Y-m-d')
    : \DateTime::createFromFormat('d/m/Y', $dateStart)->format('Y-m-d');

$dateEnd = $dateEnd instanceof \DateTime ? $dateEnd->format('Y-m-d')
    : \DateTime::createFromFormat('d/m/Y', $dateEnd)->format('Y-m-d');
```

Caso você queira debugar os valores e ver a nossa lógica funcionando, basta adicionar o método **get** e configurar a action de nosso formulário **templates/statements.html.twig**:

```html
<form class="form-inline text-center" method="get" action="{{ route('statements.list') }}">
    <div class="form-group">
        <label class="control-label">Início</label>
        <input class="form-control" type="text" placeholder="DD/MM/YYY"
               name="date_start" value="{{ 'now'|date_modify('-1 month')|date('d/m/Y') }}">
    </div>
    <div class="form-group">
        <label class="control-label">Fim</label>
        <input class="form-control" type="text" placeholder="DD/MM/YYY"
               name="date_end" value="{{ 'now'|date('d/m/Y') }}">
    </div>
    <button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-search"></span>
    </button>
</form>
```

Depois adicione **print_r**, nas variáveis, e destrua a aplicação com o método **die()**. Veja código abaixo:

```php
use Psr\Http\Message\ServerRequestInterface;

$app
    ->get('/statements', function(ServerRequestInterface $request) use($app){
        $view = $app->service('view.renderer');
        $data = $request->getQueryParams();
        
        $dateStart = $data['date_start'] ?? (new \DateTime())->modify('-1 month');
        $dateStart = $dateStart instanceof \DateTime ? $dateStart->format('Y-m-d')
            : \DateTime::createFromFormat('d/m/Y', $dateStart)->format('Y-m-d');
        
        $dateEnd = $data['date_end'] ?? new \DateTime();
        $dateEnd = $dateEnd instanceof \DateTime ? $dateEnd->format('Y-m-d')
            : \DateTime::createFromFormat('d/m/Y', $dateEnd)->format('Y-m-d');

        // Remover este código após debugar
        print_r($dateStart);
        print_r($dateEnd);
        die();

        return $view->render('statements.html.twig');
    }, 'statements.list');
```

Desta forma, se acessar **http://localhost:8000/statements**, terá as data inicial e final que definimos no formulário, mas caso queira testar outras datas, adicione os parâmetros na URL. Veja exemplo abaixo:

**http://localhost:8000/statements?date_start=24/03/2017&date_end=12/12/2017**

Acessando este URL terá as datas, passadas como parâmetro, no formato que desejamos para efetuarmos as buscas no banco, o que faremos no próximo módulo.

Não se esqueça de remover o código abaixo, que serve apenas para debugar e testar nossa lógica.

```php
print_r($dateStart);
print_r($dateEnd);
die();
```

# Conclusão do módulo

Neste módulo nós apenas formatamos as datas para o formato correto, que são gravadas no banco de dados. Assim não teremos problemas no momento de gerar os extratos com dados do banco. Também tratamos erros de formulários com valores nulos, fazendo como que sempre um valor seja atribuído as variáveis.

O próximo passo é desenvolver as buscas para depois exibir o extrato na view.