# Terminando consulta de extrato

No módulo passado, estruturamos o método **all**, que será responsável por trazer os resultados do extrato do banco de dados, através da data inicial, data final e id do usuário.

Puderam ver que a busca para contas a pagar é mais complexa porque temos categorias relacionadas e mostraremos o nome delas no resultado.

O nosso objetivo é unir as duas buscas, tanto os resultados de contas a pagar, quanto o resultado de contas a receber, e  ordenar por data de lançamento. Para este procedimento utilizaremos as coleções o Eloquent.

Veja como ficará nosso repository **src/Repository/StatementRepository.php**:

```php
namespace SONFin\Repository;

use Illuminate\Support\Collection;
use SONFin\Models\BillPay;
use SONFin\Models\BillReceive;

class StatementRepository implements StatementRepositoryInterface
{

    public function all(string $dateStart, string $dateEnd, int $userId): array
    {
        //select from bill_pays left join category_costs
        $billPays = BillPay::query()
            ->selectRaw('bill_pays.*, category_costs.name as category_name')
            ->leftJoin('category_costs', 'category_costs.id', '=', 'bill_pays.category_cost_id')
            ->whereBetween('date_launch', [$dateStart, $dateEnd])
            ->where('bill_pays.user_id', $userId)
            ->get();

        $billReceives = BillReceive::query()
            ->whereBetween('date_launch', [$dateStart, $dateEnd])
            ->where('user_id', $userId)
            ->get();

        //$billPays -> Collection [0 => BillPay, 1 => BillPay..]
        //$billReceives -> Collection [0 => BillReceive,1 => BillReceive..]

        $collection = new Collection(array_merge_recursive($billPays->toArray(), $billReceives->toArray()));
        $statements = $collection->sortByDesc('date_launch');
        return [
            'statements' => $statements,
            'total_pays' => $billPays->sum('value'),
            'total_receives' => $billReceives->sum('value')
        ];
    }
}
```

Adicionamos um comentário mostrando que, no final da busca, teremos duas **collections**: *$billPays* e *$billReceives*.

Como nosso objetivo é organizar os dois resultados por ordem de *data de lançamento*, teremos que mesclar os dois resultados para depois conseguir organizar. Por este motivo utilizamos a classe **Collection** passando, como parâmetro as duas coleções aplicando a função, do PHP, *array_merge_recursive* que faz estas mescla pra gente.

No final teremos a variável **$collection** com as duas coleções em formato de array, pois aplicamos o método **toArray** ao passar os parâmetros.

Com esta variável, temos uma nova collection com todos os resultados então aplicamos o método **sortByDesc** e passamos o nome do campo que a função irá ter como base para organizar. No final deste procedimento teremos uma variável chamada **statements** com os dados já na ordem de data de lançamento e mesclados.

Mas como queremos passar outros valores para a view, além destes resultados, criamos mais duas variáveis: **total\_pays** e **total\_receives**. Estas duas variáveis contem a soma de todos os elementos e para chegar a este resultado utilizamos o método, já presente na collection do Eloquent, chamado **sum**.

Desta forma estamos passando a coleção de resultados, já ordenados, o total de contas a pagar e o total de contas a receber para a view.

Com o repository criado temos que registrá-lo em nossa aplicação. Em **src/Plugins/DbPlugin.php** adicione o seguinte código:

```php
$container->addLazy('statement.repository', function () {
    return new StatementRepository();
});
```

Adicione depois do último registro *lazy*.

E depois de registrar teremos que executar nosso repository em nosso controller.

Código do arquivo **src/controllers/statements.php**

```php
use Psr\Http\Message\ServerRequestInterface;

$app
    ->get('/statements', function(ServerRequestInterface $request) use($app){
        $view = $app->service('view.renderer');
        $repository = $app->service('statement.repository');
        $auth = $app->service('auth');
        $data = $request->getQueryParams();

        $dateStart = $data['date_start'] ?? (new \DateTime())->modify('-1 month');
        $dateStart = $dateStart instanceof \DateTime ? $dateStart->format('Y-m-d')
            : \DateTime::createFromFormat('d/m/Y', $dateStart)->format('Y-m-d');

        $dateEnd = $data['date_end'] ?? new \DateTime();
        $dateEnd = $dateEnd instanceof \DateTime ? $dateEnd->format('Y-m-d')
            : \DateTime::createFromFormat('d/m/Y', $dateEnd)->format('Y-m-d');

        $statements = $repository->all($dateStart, $dateEnd, $auth->user()->getId());

        return $view->render('statements.html.twig', [
            'statements' => $statements
        ]);
    }, 'statements.list');
```

Primeiro carregamos o repository, que acabamos de registrar.

`$repository = $app->service('statement.repository');`

Depois carregamos o serviço *auth*, para termos acesso ao *id* do usuário.

`$auth = $app->service('auth');`

E, por último, chamamos o nosso método **all**, passando os parâmetro necessários.

`$statements = $repository->all($dateStart, $dateEnd, $auth->user()->getId());`

Depois disso só passamos o resultado para a view.

### Mostrando resultados na view

```html
{% extends 'layout.html.twig' %}

{% block content %}
    <div class="container">
        <div class="row">
            <div class="panel panel-primary">
                <div class="panel-heading">
                    <h3 class="panel-title">
                        Extrato
                    </h3>
                </div>
                <div class="panel-body">
                    <form class="form-inline text-center" method="get" action="{{ route('statements.list') }}">
                        <div class="form-group">
                            <label class="control-label">Início</label>
                            <input class="form-control" type="text" placeholder="DD/MM/YYY"
                                   name="date_start" value="{{ 'now'|date_modify('-1 month')|date('d/m/Y') }}">
                        </div>
                        <div class="form-group">
                            <label class="control-label">Fim</label>
                            <input class="form-control" type="text" placeholder="DD/MM/YYY"
                                   name="date_end" value="{{ 'now'|date('d/m/Y') }}">
                        </div>
                        <button type="submit" class="btn btn-primary">
                            <span class="glyphicon glyphicon-search"></span>
                        </button>
                    </form>
                    <div class="text-center">
                        <h2>Totais no período</h2>
                        <p>
                            <strong>Recebidos:</strong>
                            R$ {{ statements.total_receives|number_format(2,',','.') }}
                        </p>
                        <p>
                            <strong>Pagos:</strong>
                            R$ {{ statements.total_pays|number_format(2,',','.') }}
                        </p>
                        <p>
                            <strong>Total:</strong>
                            R$ {{ (statements.total_receives - statements.total_pays)|number_format(2,',','.') }}
                        </p>
                    </div>
                    <div class="col-md-8 col-md-offset-2">
                        <div class="list-group">
                            {% for statement in statements.statements %}
                                {% set isBillPay = statement.category_name is not null %}
                                <a href="#" class="list-group-item">
                                    <h4 class="list-group-item-heading">
                                        <span class="glyphicon glyphicon-{{ isBillPay?'minus':'plus' }}">
                                            {{ statement.date_launch|date('d/m/Y') }} - {{ statement.name }}
                                        </span>
                                    </h4>
                                    {% if isBillPay %}
                                        <p class="list-group-item-text">
                                            {{ statement.category_name }}
                                        </p>
                                    {% endif %}
                                    <h4 class="text-right">
                                        <span class="label label-{{ isBillPay?'danger':'success' }}">
                                           R$ {{ isBillPay?'-':'' }}{{ statement.value|number_format(2,',','.') }}
                                        </span>
                                    </h4>
                                    <div class="clearfix"></div>
                                </a>
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}
```

Acima adicionamos o código completo, mas agora vamos falar em casos separados. O fomulário já existia antes, então você já está ciente.

Depois do fomulário criamos uma div para mostrar os totais e o saldo, referentes ao extrato.

```html
<div class="text-center">
    <h2>Totais no período</h2>
    <p>
        <strong>Recebidos:</strong>
        R$ {{ statements.total_receives|number_format(2,',','.') }}
    </p>
    <p>
        <strong>Pagos:</strong>
        R$ {{ statements.total_pays|number_format(2,',','.') }}
    </p>
    <p>
        <strong>Total:</strong>
        R$ {{ (statements.total_receives - statements.total_pays)|number_format(2,',','.') }}
    </p>
</div>
```

Vejam que esta parte é bem simples, estamos apenas mostrando os dados que vem do controller e que foi obtido através do método **all**. Então apenas adicionamos o HTML, utilizando o **Bootstrap**, mas você pode estilizar da maneira que achar melhor, depois imprimimos os valores utilizando o filtro **number_format** para mantermos o padrão de dinheiro.

A listagem de contas a pagar e a receber é um pouco mais complexa, porque envolve algumas lógicas para saber se faz parte de contas a pagar ou contas a receber, mas também não tem nada de muito complicado. Veja o código abaixo:

```html
<div class="col-md-8 col-md-offset-2">
    <div class="list-group">
        {% for statement in statements.statements %}
            {% set isBillPay = statement.category_name is not null %}
            <a href="#" class="list-group-item">
                <h4 class="list-group-item-heading">
                    <span class="glyphicon glyphicon-{{ isBillPay?'minus':'plus' }}">
                        {{ statement.date_launch|date('d/m/Y') }} - {{ statement.name }}
                    </span>
                </h4>
                {% if isBillPay %}
                    <p class="list-group-item-text">
                        {{ statement.category_name }}
                    </p>
                {% endif %}
                <h4 class="text-right">
                    <span class="label label-{{ isBillPay?'danger':'success' }}">
                       R$ {{ isBillPay?'-':'' }}{{ statement.value|number_format(2,',','.') }}
                    </span>
                </h4>
                <div class="clearfix"></div>
            </a>
        {% endfor %}
    </div>
</div>
```

O primeiro passo é fazer a estrutura de repetição para imprimir todos os resultados.

Depois nós estamos atribuindo, a variável *isBillPay*, o valor de verdadeiro ou falso. Caso exista o valor da categoria, quer dizer que é uma conta a pagar, caso seja null o valor será false. Resumindo estamos verificando se é uma conta a pagar ou não.

Esta variável será muito importante no restante do código porque ela será o modificador entre os resultados.

Vejam que no primeiro **h4** já fazemos um teste para saber se é conta a pagar ou a receber, utilizando esta variável. Caso seja conta a pagar colocamos um sinal de subtração, caso contrário um sinal de adição. Depois adicionamos a data de lançamento e também o nome da conta.

Depois imprimimos o nome da categoria, caso se trate de uma conta a pagar. Também utilizamos a variável **isBillPay**, para testar.

Por último, estamos imprimindo o valor de cada conta e também estamos alterando a cor, do elemento, de acordo com o tipo de conta. Mais uma vez estamos utilizando a variável **isBillPay** para fazer este teste e diferenciação.

Também estamos alterando o sinal dos valores para positivo e negativo de acordo com o tipo das contas. Depois basta imprimir o valor de cada conta utilizando o filtro para manter o padrão de dinheiro brasileiro.

***

No próximo módulo testaremos para que você possa ver o resultado de toda nossa lógica funcionando no navegador.