# CRUD de categorias com usuários

No último módulo nós relacionamos os usuários com as categorias de centro de custo. Agora temos que adaptar o CRUD a estas mudanças, para que cada usuário seja responsável por suas categorias e também por ver apenas os dados a eles relacionados.

Veja as adaptações no arquivo **src/controllers/category-costs.php**:

```php
$app
->get('/category-costs', function() use($app){
    $view = $app->service('view.renderer');
    $repository = $app->service('category-cost.repository');
    $auth = $app->service('auth');
    $categories = $repository->findByField('user_id', $auth->user()->getId());
    return $view->render('category-costs/list.html.twig',[
        'categories' => $categories
    ]);
}, 'category-costs.list')
->post('/category-costs/store', function(ServerRequestInterface $request) use($app){
    $data = $request->getParsedBody();
    $repository = $app->service('category-cost.repository');
    $auth = $app->service('auth');
    $data['user_id'] = $auth->user()->getId();
    $repository->create($data);
    return $app->redirect('/category-costs');
}, 'category-costs.store')
->post('/category-costs/{id}/update', function(ServerRequestInterface $request) use($app) {
    $repository = $app->service('category-cost.repository');
    $id = $request->getAttribute('id');
    $data = $request->getParsedBody();
    $auth = $app->service('auth');
    $data['user_id'] = $auth->user()->getId();
    $repository->update($id, $data);
    return $app->route('category-costs.list');
}, 'category-costs.update')
```

Para as rotas criadas acima apenas incluímos as informações do *ID* do usuário para que pudéssemos filtrar os dados.

Percebam que na primeira rota, onde listávamos todas as categorias agora só listamos as categorias relacionadas ao usuário que está logado.

Nas rotas de criação e atualização estamos informando também o id do usuário para que possamos garantir o relacionamento correto entre usuário e categoria.

Existem outras rotas que precisam de uma atenção maior. Veja abaixo:

```php
->get('/category-costs/{id}/show', function(ServerRequestInterface $request) use($app){
    $view = $app->service('view.renderer');
    $id = $request->getAttribute('id');
    $repository = $app->service('category-cost.repository');
    $category = $repository->find($id);
    return $view->render('category-costs/show.html.twig', [
        'category' => $category
    ]);
}, 'category-costs.show')
```

Nesta rota estamos buscando os dados da categoria apenas pelo ID, passado na URL, como parâmetro. Porém se um usuário ficar chutando valores pode ser que ele encontre categorias de outros usuários e esta seria uma brecha na segurança de nossa aplicação.

Para resolver este problema teremos que implementar um novo método. Então primeiro vamos adicionar o método a nossa interface **src/Repository/RepositoryInterface.php**:

```php
public function findOneBy(array $search);
```

Depois de adicionar este método a interface implemente no arquivo **src/Repository/DefaultRepository.php** da seguinte maneira:

```php
public function findOneBy(array $search)
{
    $queryBuilder = $this->_model;
    foreach ($search as $field => $value){
        $queryBuilder = $queryBuilder->where($field, '=', $value);
    }

    return $queryBuilder->firstOrFail();
}
```

Agora que fizer estas alterações troque os métodos *find* pelo nosso novo método *findOneBy*. Veja como ficou:

```php
->get('/category-costs/{id}/edit', function(ServerRequestInterface $request) use($app){
    $view = $app->service('view.renderer');
    $id = $request->getAttribute('id');
    $repository = $app->service('category-cost.repository');
    $auth = $app->service('auth');
    $category = $repository->findOneBy([
        'id' => $id,
        'user_id' => $auth->user()->getId()
    ]);
    return $view->render('category-costs/edit.html.twig', [
        'category' => $category
    ]);
}, 'category-costs.edit')
->get('/category-costs/{id}/show', function(ServerRequestInterface $request) use($app){
    $view = $app->service('view.renderer');
    $id = $request->getAttribute('id');
    $repository = $app->service('category-cost.repository');
    $auth = $app->service('auth');
    $category = $repository->findOneBy([
        'id' => $id,
        'user_id' => $auth->user()->getId()
    ]);
    return $view->render('category-costs/show.html.twig', [
        'category' => $category
    ]);
}, 'category-costs.show')
```

Vejam que primeiro procuramos por *id*, da categoria, com chave e valor, através do nosso novo método, depois pesquisamos por *user_id* passando o *id* do usuário logado. Desta forma estamos filtrando e relacionando os resultados.

Desta forma estaria correto, mas ainda temos o **update** e o **delete** recebendo o **id** da categoria diretamente, sem filtrar por id do usuário. Então teremos que fazer mais uma adaptação em nossa interface e também aplicar no arquivo *DefaultRepository.php*. Veja a alteração na interface:

```php
public function update($id, array $data);
public function delete($id);
```

A nossa alteração foi remover a obrigatoriedade do parâmetro **$id** ser um número inteiro, como tiramos o **int** significa que agora ele pode tanto ser um inteiro como pode ser um array. Sendo um array, podemos aplicar o método **findOneBy** e caso seja inteiro podemos aplicar o método **find**. Para isso precisaremos alterar o método. Veja:

```php
public function update($id, array $data)
{
    $model = $this->findInternal($id);  
    $model->fill($data);
    $model->save();
    return $model;
}

public function delete($id)
{
    $model = $this->findInternal($id);
    $model->delete();
}

protected function findInternal($id)
{
    return is_array($id) ? $this->findOneBy($id) : $this->find($id);
}
```

Verificamos o tipo do parâmetro **id**, desta forma não alteramos nossa forma de trabalhar e conseguimos alterar o tipo do método aplicado de acordo com o parâmetro que passamos.

Depois de fazer estas alterações, basta alteramos o modo de passar o parâmetro **id** em nosso controller **src/controllers/category-costs.php**. Veja:

```php
->post('/category-costs/{id}/update', function(ServerRequestInterface $request) use($app) {
    $repository = $app->service('category-cost.repository');
    $id = $request->getAttribute('id');
    $data = $request->getParsedBody();
    $auth = $app->service('auth');
    $data['user_id'] = $auth->user()->getId();
    $repository->update([
        'id' => $id,
        'user_id' => $auth->user()->getId()
    ], $data);
    return $app->route('category-costs.list');
}, 'category-costs.update')
->get('/category-costs/{id}/delete', function(ServerRequestInterface $request) use($app){
    $repository = $app->service('category-cost.repository');
    $id = $request->getAttribute('id');
    $auth = $app->service('auth');
    $repository->delete([
        'id' => $id,
        'user_id' => $auth->user()->getId()
    ]);
    return $app->route('category-costs.list');
}, 'category-costs.delete');
```

Não se esqueça de fazer alguns testes em sua aplicação para ver se nenhum método foi aplicado errado, você deverá conseguir adicionar, editar e excluir normalmente suas categorias.