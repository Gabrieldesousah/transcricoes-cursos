# Trabalhando com ajax_select na área administrativa

Uma das características mais importantes, ao trabalhar com a area administrativa do Django, é a facilidade e praticidade de gerenciamento dos dados.

Citando um exemplo da nossa realidade, para o projeto, imagine que você precise cadastrar um produto e tem que relacionar o mesmo a um usuário, até este ponto maravilha, mas pense que pode existir dez mil usuários. Tente imagina um campo de select com esta quantidade de usuários, ficaria muito complicado de se trabalhar desta forma, e não é esta nossa intenteção. Nosso objetivo é sempre facilitar a usabilidade.

Uma forma de resolver este problema seria o uso de um **autocomplete** e para isso existe um pacote para o Django, chamado **Django Ajax Selects**.

Você pode pesquisar no Google por *django ajax selects* ou acessar diretamente uma das URLs abaixo:

<http://django-ajax-selects.readthedocs.io/en/latest/Install.html>
<https://github.com/crucialfelix/django-ajax-selects>

De qualquer forma, para instalar este pacote utilizaremos o **pip**, como estamos utilizando nos demais pacotes, em nosso projeto.

`pip install django-ajax-selects`

A instalação não deve demorar, pois o pacote não é extenso. Depois de fazer a instalação teremos que registrar nosso módulo para que ele seja reconhecido e carregado pelo Django. Para isso adicionaremos **ajax_select** no arquivo **mktplace/settings.py**.

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'ajax_select',
    'portal',
]
```

O próximo procedimento será a criação de um arquivo, chamado **lookups.py**, na pasta raiz de **portal**. Este arquivo será responsável por nos auxiliar nas buscas para exibição dos selects. Óbviamente este arquivo utilizará o **ajax_select**.

```python
from ajax_select import register, LookupChannel
from django.contrib.auth.models import User

from portal.models import Category


@register('user')
class UserLookup(LookupChannel):
    model = User

    def get_query(self, q, request):
        return self.model.objects.filter(username__icontains=q).order_by('username')


@register('categories')
class CategoryLookup(LookupChannel):
    model = Category

    def get_query(self, q, request):
        return self.model.objects.filter(name__icontains=q).order_by('name')
```

Primeiro estamos importando **register**, **LookupChannel** e os models **User** e **Category**, para nos auxiliar no desenvolvimento deste arquivo.

Depois criamos as classes **UserLookup** e **CategoryLookup**, registrando os lookups como **user** e **categories** sucessivamente.

Vejam que o procedimento, em ambos, é informar o model, cuja busca será efetuada, depois definir a **query**. Para definição da query utilizamos o método **get_query**, onde é passado, como parâmetro, a própria classe(**self**), o valor digitado(**q**) e a requisição(**request**).

Isso quer dizer que a classe irá filtrar os resultados de acordo com o que o usuário digitar diminuindo assim a quantidade de resultados para os campos de select.

| Método | Descrição |
| ------ | --------- |
| self.model.objects.filter(username__icontains=q) | Filtra valores cujo **username** contenham o valor digitado(q) |
| self.model.objects.filter(name__icontains=q) | Filtra valores cujo **name** contenham o valor digitado(q) |
| order_by('username') | Organiza o resultado por username |
| order_by('name') | Organiza o resultado por name |

Estamos acessando a classe(self), depois o model, depois os objetos e, por último, o método de filtro, onde o resultado é processado e retornado.

`return self.model.objects.filter(nome_do_campo__icontains=q)`

### Utilizando os resultados nos models

> Classe CategoryAdmin e ProductAdmin

```python
from ajax_select import make_ajax_form
from ajax_select.admin import AjaxSelectAdmin
from django.contrib import admin

from portal.models import Category, Product, ProductAnswer, ProductQuestion


class CategoryAdmin(AjaxSelectAdmin):
    prepopulated_fields = {"slug": ('name',)}
    list_filter = ['hidden']
    list_display = ('id', 'name', 'parent', 'hidden')
    form = make_ajax_form(Category, {
        'parent': 'categories',
    })


class ProductAdmin(AjaxSelectAdmin):
    prepopulated_fields = {"slug": ('name',)}
    list_filter = ['status']
    list_display = ('id', 'name', 'short_description', 'status')
    form = make_ajax_form(Product, {
        'user': 'user',
        'categories': 'categories'
    })
```

Veja que importamos **make_ajax_form** e **AjaxSelectAdmin**, pois quando trabalhamos com estes campos de autocomplete temos extender de outra classe e utilizar este método *make_ajax_form*.

Percebam que anteriormente extendíamos da classe **admin.ModelAdmin** e agora extendemos de **AjaxSelectAdmin**.

Depois de importar as classes extendidas temos que sobrescrever o método **form**, utilizando o método make_ajax_form para trazer os resultados da busca do formulário. Por este motivo informamos que quando se tratar do campo **user** a aplicação deve buscar os resultados da lookup **user** e quando for o campo **parent** deverá buscar os dados na lookup **categories**.

Teóricamente poderia estar tudo correto e configurado, mas ainda temos que registrar a url para que o **ajax_select** não retorne um erro, pois ele não conseguirá encontrar esta url originalmente.

Existe um arquivo, dentro da pasta mktplace, chamado **urls.py**. Este arquivo deverá ser alterado, veja o código abaixo:

```python
from django.conf.urls import url, include
from django.contrib import admin
from ajax_select import urls as ajax_select_urls

urlpatterns = [
    url(r'^ajax_select/', include(ajax_select_urls)),
    url(r'^admin/', admin.site.urls),
]
```

Depois de configurar as nossas areas administrativas e adicionar a configuração para as urls, podemos utilizar nossos campos selects com autocomplete, desta forma temos uma aplicação mais completa e mais prática para utilização.

Podemos ter muitos usuário e muitas categorias que não teremos trabalho algum ao cadastrar novos produtos, categorias, perguntas e respostas.