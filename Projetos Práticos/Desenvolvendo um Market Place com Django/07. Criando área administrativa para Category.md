# Criando área administrativa para Category

No módulo anterior criamos um model, chamado **Category**, criamos as migrações e as rodamos.

O nosso objetivo agora é permitir que o usuário possa gerenciar os dados de Category, assim como os recursos nativos do Django, então criaremos uma area administrativa para categorias.

Dentro da aplicação **portal**, que criamos em módulos anteriores, existe um arquivo chamado **admin.py**. É neste arquivo que conseguimos habilitar o painel de administração e fazer as configurações necessárias para cada modelo criado. Veja o código abaixo:

```python
from django.contrib import admin

from portal.models import Category


class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {"slug": ('name',)}
    list_filter = ['hidden']
    list_display = ('id', 'name', 'parent', 'hidden')

admin.site.register(Category, CategoryAdmin)
```

Com apenas este código acima você já terá uma area administrativa para gerenciar todas as categorias.

Estamos importanto **admin**, que é nativo e o modelo **Category**, porque estamos utilizando no registro do painel. Veja abaixo:

`admin.site.register(Category, CategoryAdmin)`

Para criar a configuração da administração temos que criar uma classe, que em nosso caso chamamos de **CategoryAdmin**, onde extendemos de **admin.ModelAdmin**, que trás todo gerenciamento por herança.

Dentro desta clase estamos configurando um campo que é auto-populado, ou seja, enquanto estivermos preenchendo o nome da categoria, o campo **slug** estará sendo preenchido automaticamente, com o formato desejado do slug.

Estamos registrando um filtro por relacionado ao campo **hidden**, ou seja, teremos um filtro para listar somente categorias ocultas ou categorias visíveis.

Depois estamos informando quais campos devem estar visíveis na listagem de categorias, para isso basta sobrescrevermos o atributo **list_display**, que vem da classe principal.

Depois de criar o gerencicador de categorias, é bom que teste em seu navegador, criando uma ou mais categorias. Aproveite o teste para filtrar por categorias do tipo *hidden* ou do tipo não *hidden*.

Ao acessar a página inicial do painel verá que o plural da palavra *Category* está errada. O sistema pluralizou como **Categorys** e para corrigir temos que acessar o arquivo **portal/models.py**.

```python
from django.db import models


class Category(models.Model):
    name = models.CharField(max_length=255)
    slug = models.SlugField(unique=True)
    parent = models.ForeignKey('Category', null=True, blank=True, related_name='cat_child')
    order = models.IntegerField(null=True, blank=True)
    hidden = models.BooleanField(default=False)

    class Meta:
        verbose_name_plural = 'Categories'

    def __str__(self):
        return self.name
```

Vejam que para correção adicionamos a classe **Meta**, passando o valor correto do plural para o atributo **verbose_name_plural**.

```python
class Meta:
    verbose_name_plural = 'Categories'
```

Em seus testes você pôde ver que o nosso select de categorias está mostrando um objeto(**Category object**), no lugar do nome das categorias criadas, isso é porque não definimos qual o valor que deve ser impresso pelo método **__str__**(toString). Caso não informamos o Django retorna o objeto puro, isso acontece em outras linguagens também não somente no Python. Por este motivo adicionamo o código abaixo:

```python
def __str__(self):
    return self.name
```

Desta forma estamos definindo que a função *toString*, retornará não mais o objeto puro, mas sim o campo *name* do objeto somente.

Para testar o resultado desta alteração basta você criar uma nova sub-categoria e ao selecionar a categoria pai, você verá que não se trata mais de um *Category object*, mas sim o nome da categoria registrada anteriormente.

Vale a pena informar que, mesmo depois de tudo criado e configurado, é possível alterar campos, remover e adicionar campos em nosso modelo, tudo isso veremos em módulos futuros, não será preciso criar tudo novamente.

Desta forma finalizamos o gerenciamento da categorias, no próximo módulo faremos o mesmo processo para os produtos.