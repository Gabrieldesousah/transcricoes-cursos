# Gerenciamento de perguntas e respostas

Nosso projeto terá comunicação entre comprador e vendedor, então teremos que criar um sistema de envio de perguntas e respostas.

Para isso criaremos dois modelos para gerenciar esta comunicação.

```python
class ProductQuestion(models.Model):
    user = models.OneToOneField(User)
    product = models.ForeignKey('Product')
    question = models.TextField()
    STATUS_CHOICES = (
        ('Active', 'Active'),
        ('Inactive', 'Inactive'),
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="Active")

    class Meta:
        verbose_name_plural = "Product Questions"

    def __str__(self):
        return self.question


class ProductAnswer(models.Model):
    user = models.OneToOneField(User)
    product_question = models.ForeignKey(ProductQuestion)
    answer = models.TextField()
    STATUS_CHOICES = (
        ('Active', 'Active'),
        ('Inactive', 'Inactive'),
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="Active")

    class Meta:
        verbose_name_plural = "Answers"

    def __str__(self):
        return self.answer
```

A medida que vamos avançando o reaproveitamente de código aumenta, você pode perceber que tem muita coisa que podemos copiar e colar, em nossos modelos, porque são códigos parecidos e muitas vezes idênticos.

### ProductQuestion

> user

Todo question será relacionado a um usuário.

> product

Toda question terá uma relação direta com um produto, por isso teremos uma chave estrangeira para fazer o relacionamento.

> question

O campo question será um campo de texto normal e sem limitação de caracteres.

> status

Este campo tem duas escolhas: **Active** e **Inactive**. O valor padrão será *active*, desta forma, quando o vendedor quiser encerrar o questionamento ele deverá alterar este status para inactive.

### ProductAnswer

> user

Toda answer será relacionado a um usuário.

> product_question

Toda answer terá uma relação direta com uma question, por isso teremos uma chave estrangeira para fazer o relacionamento.

> answer

O campo answer será um campo de texto normal e sem limitação de caracteres.

> status

Este campo tem duas escolhas: **Active** e **Inactive**. O valor padrão será *active*, desta forma, quando o vendedor quiser encerrar o questionamento ele deverá alterar este status para inactive.

***

Em ambos os modelos estamos configurando o plural que desejamos, através da classe Meta e da constante **verbose_name_plural**, e também estamos definindo o item a ser impresso pelo método toString.

Depois de criar os modelos vamos gerar e rodar as migrações.

`.\manage.py makemigrations`

```
Migrations for 'portal':
  portal/migrations/0003_auto_20170605_1438.py
    - Create model ProductAnswer
    - Create model ProductQuestion
    - Add field product_question to productanswer
    - Add field user to productanswer
```

`.\manage.py migrate`

```
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, portal, sessions
Running migrations:
  Applying portal.0003_auto_20170605_1438... OK
```

### Criando area administrativa para perguntas e respostas

```python
from django.contrib import admin

from portal.models import Category, Product, ProductAnswer, ProductQuestion


class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {"slug": ('name',)}
    list_filter = ['hidden']
    list_display = ('id', 'name', 'parent', 'hidden')


class ProductAdmin(admin.ModelAdmin):
    prepopulated_fields = {"slug": ('name',)}
    list_filter = ['status']
    list_display = ('id', 'name', 'short_description', 'status')


class ProductAnswerInline(admin.StackedInline):
    model = ProductAnswer
    can_delete = False


class ProductQuestionAdmin(admin.ModelAdmin):
    list_display = ('id', 'product', 'question', 'status')
    inlines = (ProductAnswerInline,)


admin.site.register(Category, CategoryAdmin)
admin.site.register(Product, ProductAdmin)
admin.site.register(ProductQuestion, ProductQuestionAdmin)
```

Estamos importando as classes, assim como todo os outros casos anteriories.

`from portal.models import Category, Product, ProductAnswer, ProductQuestion`

Porque estamos registrando duas areas administrativas em apenas uma.

`admin.site.register(ProductQuestion, ProductQuestionAdmin)`

A grande diferença entre esta area administrativa para as outras é que estamos listando as respostas de forma integrada, ou seja, **inline**.

Percebam que estamos criando a classe de respostas extendendo de uma classe diferente: **admin.StackedInline**.

Extendendo desta forma temos que informar o modelo que estamos nos referindo. O model apontado foi **ProductAnswer** e informamos que não será possível deletar nenhum registro, através do parâmetro **can_delete**, que setamos como false.

Ao criar a classe de gerenciamento de perguntas **ProductQuestionAdmin**, apenas mostramos os itens de listagem e informamos que existem itens **inline**. Para exibir os itens inlines basta sobresquecer o atributo **inlines** informandos os itens, que, em nosso caso, se trata da classe **ProductAnswerInline**.

Desta forma teremos as respostas sendo mostradas dentro da administração de cada pergunta, podendo adicionar novas resposta caso seja necessário.

Depois de fazer estas alterações faça novos testes de perguntas e respostas.

Lógicamente que o usuário final não terá acesso a esta area administrativa do Django, mas o que gostaríamos de frisar é que o painel administrativo do Django é um recurso maravilhoso, que o framework nos oferece, porque nos poupa de ficar criando muitos CRUDs desnecessários.

Conseguirmos fazer esta administração completa com muito pouco código e de uma forma muito simples.