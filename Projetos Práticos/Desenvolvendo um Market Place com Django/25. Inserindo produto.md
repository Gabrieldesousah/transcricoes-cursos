# Inserindo produto

No módulo anterior nós geramos o formulário de forma completa, sem que pudéssemos estilizar ou gerar de forma separada, campo a campo.

Neste módulo mostraremos como gerar campo por campo, independentemente, para que possamos estilizar, da maneira que quisermos, e também utilizar o HTML da maneira que quisermos, para fazer a marcação dos campos.

Faremos um exemplo simples para você entender como funciona o processo de renderização independente. Faremos a impressão do campo name no arquivo **portal/templates/portal/product_new.html**

```html
<form action="" method="post">
    {% csrf_token %}
    <div class="row">
        <div class="col-md-6">
            <span class="text-danger">{{ form.name.errors }}</span>
        </div>
        <div class="form-group">
            <label>
                {{ form.name.label }}
            </label>
            {{ form.name }}
        </div>
    </div>
</form>
```

Do mesmo jeito que renderizamos o campo **name** com a tag **{{ form.name }}**, poderíamos renderizar todos os outros.

* {{ form.categories }}
* {{ form.quantity }}
* {{ form.price }}
* {{ form.short_description }}
* {{ form.description }}

Agora você já sabe como renderizar campos separadamente. Desta forma você pode criar qualquer tipo de layout, para seus formulários, facilitando a estilização.

Nós continuaremos com o modelo antigo, mas não poderíamos deixar de mostrar como realizar este procedimento, porque, em muitos casos, você tem que seguir um padrão de layout e, desta maneira, fica muito mais fácil.

### Criando inserção de dados

Já possuímos a função **product_new**, que renderizar a view de cadastro de novo produto, porém alteraremos para que ela seja capaz de diferenciar uma postagem e uma renderização, ou seja, caso a função reconheça o método post ela faz a inserção no banco de dados, caso contrário ela apenas renderiza a view com o formulário em branco.

```python
from django.shortcuts import render, redirect

def product_new(request):

    if request.method == 'POST':
        form = ProductForm(request.POST)
        if form.is_valid():
            product = Product()
            product.user = request.user
            product.name = form.cleaned_data['name']
            product.quantity = form.cleaned_data['quantity']
            product.price = form.cleaned_data['price']
            product.short_description = form.cleaned_data['short_description']
            product.description = form.cleaned_data['description']
            product.categories = form.cleaned_data['category']
            product.status = 'Active'
            product.save()
            return redirect('my_products')

    form = ProductForm()

    context = {
        "form": form
    }

    return render(request, 'portal/product_new.html', context)
```

As principais diferenças foram:

1. Importamos a classe **redirect**, que ainda não tínhamos importado, e removemos **render_to_response**, pois não estávamos mais utilizando.
2. Instanciamos um objeto de **Product** e preenchemos, atributo por atributo, utilizando o **cleaned_data**, para garantir a segurança dos dados. E, no final, executamos o método **save** para salvar os dados e retornar para a listagem de produtos.
	* Os dados que estamos submetendo ao *cleaned_data* vieram do preenchimento do formulário e estão presentes na requisição.

Percebam que caso não seja uma submissão de formulário, e não entre no bloco condicional **if**, estamos mantendo o processo anterior de renderização com um formulário em branco para o usuário, porém removemos a propriedade **categories** da variável *context*, porque estamos passando diretamente na criação do campo, no arquivo **forms.py**.

Aparentemente estaria tudo normal e poderíamos efetuar o cadastro do primeiro anúncio, porém teremos um erro ao tentar submeter o formulário.

O erro se deve porque temos uma tabela intermediária entre categorias e produtos. Isso se deve pela relação **many to many**, que são muitos para muitos, ou seja, ao atribuir categorias precisamos ter o **id** do produto para criar a relação, porém estamos cadastrando o produto e este id ainda não existe.

Para evitarmos este erro teremos que alterar a nossa função de cadastro de produtos. Fizemos questão de manter o erro para que você pudesse entender este processo e que não cometa este mesmo erro em aplicações futuras.

Veja o erro:

**"Product: Teste 1" needs to have a value for field "id" before this many-to-many relationship can be used.**

### Resolvendo erro

```python
def product_new(request):

    if request.method == 'POST':
        form = ProductForm(request.POST)
        if form.is_valid():
            product = Product()
            product.user = request.user
            product.name = form.cleaned_data['name']
            product.quantity = form.cleaned_data['quantity']
            product.price = form.cleaned_data['price']
            product.short_description = form.cleaned_data['short_description']
            product.description = form.cleaned_data['description']
            product.status = 'Active'
            product.save()

            categories = Category.objects.filter(id__in=request.POST.getlist('categories'))
            if categories:
                for category in categories:
                    product.categories.add(category)

            return redirect('my_products')

    form = ProductForm()

    context = {
        "form": form
    }

    return render(request, 'portal/product_new.html', context)
```

Percebam as alterações:

Removemos o preenchimento das categorias antes de salvar o produto. Isso evita o erro de relacionamento entre categorias e o id do produto.

```python
# Remova esta linha
product.categories = form.cleaned_data['categories']
```

Depois de salvar o produto com o método `product.save()`, nós já possuímos o id do produto então podemos fazer o processo de adicionar as categorias ao mesmo.

```python
categories = Category.objects.filter(id__in=request.POST.getlist('categories'))
if categories:
    for category in categories:
        product.categories.add(category)
```

Primeiro pegamos as categorias selecionadas no formulário através do filtro:

`categories = Category.objects.filter(id__in=request.POST.getlist('categories'))`

| Código | Descrição |
| ------ | --------- |
| id__in | Filtra o campo **id** que pertença e esteja contido em uma coleção |
| request.POST.getlist('categories') | Informamos a coleção que o método **id__in** deve analizar e filtra os dados |

Estamos fazendo este filtro para certificar de que estamos pegamos apenas os ids das categorias, presentes no campo categories da requisição. Isso evita que alguém possa adicionar ids inexistentes para cadastro.

Depois disso fizemos um laço de repetição para percorrer todas as categorias e adicionamos, ou relacionamos, ao produto através do método **add**.

`product.categories.add(category)`

Depois de fazer esta alteração o cadastro teria que dar certo, mas verificamos um erro na estruturação do nosso model de produtos. Teremos que corrigir o erro e rodar outra vez a migration para que consigamos finalmente efetuar o cadastro dos produtos.

Veja o ponto que teremos que alterar no arquivo **portal/models.py**. Lembrando que criamos o model no módulo 08 deste conteúdo:

```python
# Criando modelo de produtos
class Product(models.Model):
	# ANTES
    user = models.OneToOneField(User)

    # DEPOIS
    user = models.ForeignKey(User)
```

Depois de fazer esta alteração rode os comandos de migration no terminal:

`.\manage.py makemigrations`

`.\manage.py migrate`

Depois destes comandos, finalmente, teremos nossos produtos sendo cadastrados sem erros.

No próximo módulo trabalharemos com a parte de edição de produtos.