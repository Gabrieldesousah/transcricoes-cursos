# Protegendo páginas internas

Do jeito que está o sistema neste momento, se o usuário não estiver logado e tentar acessar a listagem de ordens, por exemplo, o sistema dispara um erro. Isso acontece porque as rotas não estão protegidas.

O erro ocorre porque ao tentar encontrar o usuário o sistema não encontra, pois o mesmo está como **AnonymousUser**.

A partir de agora o usuário será redirecionado para a página de login, quando tentar acessar uma área restrita. Desta forma estamos protegendo as rotas e também evitando erros.

### Protegendo portal views

Abra o arquivo **portal/views**:

```python
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.core.paginator import Paginator, PageNotAnInteger, EmptyPage
from django.http import HttpResponseForbidden
from django.shortcuts import render, redirect, get_object_or_404

from portal.forms import ProductForm, ProductQuestionForm, AnswerQuestionForm, UserForm, UserProfileForm
from portal.models import Product, Category, ProductQuestion, ProductAnswer, UserProfile
import algoliasearch_django as algoliasearch


def home(request):
# Código do método

@login_required
def my_products(request):
# Código do método

@login_required
def product_new(request):
# Código do método

@login_required
def product_edit(request, product_id):
# Código do método

def product_show(request, slug):
# Código do método

@login_required
def product_new_question(request, product_id):
# Código do método

@login_required
def product_question(request, product_id):
# Código do método

@login_required
def product_answer_question(request, product_id, question_id):
# Código do método

def search(request):
# Código do método

@login_required
def my_data(request):
# Código do método
```

Realmente este processo de proteção de rotas, no Django, é muito simples. Basta adicionar a notação **@login_required** antes da definição do método e pronto.

Apenas as rotas **home**, **product_show** e **search** não serão protegidas.

Atente-se também que é necessário importar o recurso do Django para que a notação funcione corretamente.

```python
from django.contrib.auth.decorators import login_required
```

### Protegendo billing views

Abra o arquivo **billing/views.py**:

```python
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, get_object_or_404, redirect

from billing.forms import PaymentForm, EditOrderForm
from billing.models import Order
from billing.services import BillingService
from portal.models import Product

@login_required
def payment(request, product_id):
# Código do método

@login_required
def item_purchased(request, order_id):
# Código do método

@login_required
def my_orders(request):
# Código do método

@login_required
def sales(request):
# Código do método

@login_required
def change_shipment_status(request, order_id):
# Código do método
```

Não se esqueça de importar o recurso do Django para que a notação funcione corretamente.

```python
from django.contrib.auth.decorators import login_required
```

### Concluindo processo de redirecionamento

Depois de fazer as alterações acima, um erro é solucionado, porém gera um outro erro 404, que se trata de uma página não encontrada. Isso ocorre porque o sistema tenta redirecionar para uma página que não existe.

Veja a url de redirecionamento:

**http://localhost:8000/accounts/login/?next=/my\_orders**

Reparem que o sistema adiciona um parâmetro chamado **next** na url, este parâmetro guarda a rota acessada antes do login. Desta forma assim que o usuário logar o sistema redireciona para a página acessada anteriormente.

O próximo passo será configurar a página de redirecionamento. O sistema fará o redirecionamento para uma rota existente para não gerar mais o erro 404.

Abra o arquivo **mktplace/settings.py** e adicione a constante **LOGIN_URL**. Veja abaixo:

```python
LOGIN_REDIRECT_URL = '/'
LOGIN_URL = '/login'
```

Reparem que a constante **LOGIN_REDIRECT_URL** já existia anteriormente.

Adicione a nova constante e tente acessar uma página protegida novamente. Lembrando que não pode estar logado para ver o redirecionamento sendo feito.

### Ocultando formulário de perguntas

Caso o usuário não esteja logado ele não pode efetuar perguntas. Com as rotas protegidas ele realmente não conseguirá, porém o formulário ainda aparece para ele e isso é considerado um erro, apesar de haver o redirecionado para o login.

Seria melhor que este formulário não aparecesse para usuários não logados e isso é o que será feito. Abra o arquivo **portal/templates/portal/product_show.html** e faça as alterações necessárias:

```html
{% if request.user.is_authenticated %}
    <form class="questions-form" action="{% url 'product_new_question' product.id %}" method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit" class="btn btn-info">Perguntar</button>
    </form>
{% endif %}
```

A condicional verifica se o usuário está autenticado, através da requisição, caso não esteja a aplicação nem mostra o formulário.

Desta forma a proteção de páginas internas está concluída.