# Trabalhando com ModelForm

Quando criamos um novo produto, os campos do formulário sempre vem em branco, porém quando falamos de edição de um produto temos que fazer com que os campos sejam preenchidos ao renderizar, para saber qual produto estamos editando.

Da maneira que estamos trabalhando com formulários, extendendo da classe **Form**, existe uma possibilidade de preenchermos os campos, na hora da edição, porém é muito trabalhoso.

```python
def product_new(request):

    if request.method == 'POST':
        form = ProductForm(request.POST)
        if form.is_valid():
            product = Product()
            product.user = request.user
            product.name = form.cleaned_data['name']
            product.quantity = form.cleaned_data['quantity']
            product.price = form.cleaned_data['price']
            product.short_description = form.cleaned_data['short_description']
            product.description = form.cleaned_data['description']
            product.status = 'Active'
            product.save()

            categories = Category.objects.filter(id__in=request.POST.getlist('categories'))
            if categories:
                for category in categories:
                    product.categories.add(category)

            return redirect('my_products')

    # Informando valores iniciais para os campos
    form = ProductForm(initial={'': ''})

    context = {
        "form": form
    }

    return render(request, 'portal/product_new.html', context)
```

O código acima mostra o parâmetro **initial**, onde podemos passar valores iniciais para o formulário. Você poderia utilizar este método para informar campo a campo do seu formulário, caso seja uma edição, mas, mesmo funcionando, daria muito trabalho, pois imagine se fosse um formuário muito grande.

Existe uma outra forma, muito mais simples e automática, para preencher estes campos: utilizar a classe **ModelForm**.

Para utilizar este recurso do Django, teremos que modificar a forma de criação dos campos, em nosso arquivo **portal/forms.py**.

### Refatorando forms.py

Comente toda classe **ProductForm**, criada anteriormente, pois criaremos outra.

```python
# class ProductForm(forms.Form):
#     name = forms.CharField(label='Nome',
#                            max_length=255,
#                            required=True,
#                            widget=forms.TextInput(attrs={'class': 'form-control'})
#                            )
#
#     categories = forms.ModelMultipleChoiceField(label='Categorias', queryset=Category.objects.all(),
#                                               widget=forms.SelectMultiple(attrs={'class': 'form-control'})
#
#                                               )
#
#     quantity = forms.CharField(label='Quantidade',
#                                max_length=4,
#                                required=True,
#                                widget=forms.TextInput(attrs={'class': 'form-control'})
#                                )
#
#     price = forms.CharField(label='Valor',
#                             required=True,
#                             widget=forms.TextInput(attrs={'class': 'form-control'})
#                             )
#
#     short_description = forms.CharField(label='Descrição curta',
#                                         required=True,
#                                         widget=forms.TextInput(attrs={'class': 'form-control'})
#                                         )
#
#     description = forms.CharField(label='Descrição',
#                                   required=True,
#                                   widget=forms.Textarea(attrs={'class': 'form-control'})
#                                   )
```

Logo acima da classe comentada crie uma classe, com o mesmo nome, com o seguinte código:

```python
class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        exclude = ('slug', 'user',)
```

Somente a classe acima é capaz de renderizar todos os campos, pois estamos informando, através da subclass **Meta**, o model que o formulário está relacionado. Desta forma o próprio Django traz os campos de acordo com os campos da tabela do banco de dados.

Vejam que depois de informar o model, podemos excluir os campos que não queremos que pertença ao formulário. Em nosso exemplo removemos o campo slug e user, através do atributo **exclude**.

Você pode ir até seu navegador e ver que os campos já estarão criados, porém sem formatação nenhuma. Este é o próximo passo que mostraremos.

Como a classe renderiza os campos automaticamente, ela tenta adivinhar qual o tipo deles, porém temos a possibilidade de alterará-los, através do **widget**, passando o tipo do campos e as customização como: classes, atributos e etc. Veja exemplo abaixo:

```python
class ProductForm(forms.ModelForm):
    class Meta:
        model = Product
        exclude = ('slug', 'user',)

        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control'}),
            'categories': forms.SelectMultiple(attrs={'class': 'form-control'}),
            'quantity': forms.TextInput(attrs={'class': 'form-control'}),
            'price': forms.TextInput(attrs={'class': 'form-control'}),
            'short_description': forms.TextInput(attrs={'class': 'form-control'}),
            'description': forms.Textarea(attrs={'class': 'form-control'}),
            'status': forms.Select(attrs={'class': 'form-control'}),
        }

        labels = {
            'name': "Nome",
            'categories': "Categories",
            'quantity': "Quantidade",
            'price': "Preço",
            'short_description': "Descrição curta",
            'description': "Descrição",
        }
```

Desta forma, com muito menos código, temos o mesmo resultado de formulário, porém de forma dinâmica.

Além dos widgets podemos customizar também os **Labels**.

A grande vantagem, além de ter os campos gerados dinamicamente, é ter os campos preenchidos automaticamente quando se tratar de uma edição de produto.