# Enviando mensagens

Agora que já construímos a conexão junto ao servidor, chegou a hora de começarmos a consumir os dados dentro da nossa webapp. Portanto voltaremos ao projeto webapp.

A partir de agora utilizaremos o pacote socket.io para conseguir a conexão junto ao servidor de websocket.

Em primeiro lugar faremos alguns carregamentos de scripts no arquivo **webapp/src/index.html**. Veja abaixo:

```html
<!-- Carregamentos existentes -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>

<!-- Carregamentos adicionados -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.7.3/socket.io.js"></script>
<script src="./js/app.js"></script>
```

Estamos carregando o script do socket.io via CDN e um arquivo chamado **app.js**, porém este arquivo ainda não existe. O carregamento do socket.io é necessário para conseguirmos conectar ao nosso servidor de API, juntamente com o arquivo app.js.

Dentro da pasta **webapp/src/js** crie um arquivo chamado **app.js**. Veja o conteúdo do arquivo:

```js
var socket = io('//localhost:3000')

// socket.emit()
```

Por enquanto vamos deixar o evento `socket.emit()` comentado para testarmos primeiro se a conexão está sendo bem sucedida. Depois enviaremos uma mensagem do front-end para o servidor.

Para fazer o teste de conexão temos que preparar o reconhecimento do evento em nosso arquivo **api/app.js**. Veja código adicionado:

```js
// Código existente
app.use((req, res, next) => {
    res.io = io
    next()
})

// Código adicionado
io.on('connection', function () {
    console.log('A new connection has been established')
})
```

Depois que adicionar este código o servidor vai ficar aguardando uma conexão e quando nosso webapp conectar ao servidor pela url **http://localhost:3000**, o servidor dispara a mensagem no console.

Então o que precisamos fazer é executar a nossa webapp através do gulp e depois rodar nosso servidor novamente.

Para rodar o gulp acesse a pasta raiz de webapp e rode `gulp`.

Depois vá até a pasta raiz de API e rode `npm start`.

Você deverá obter a resposta abaixo, em seu terminal:

```
> api@0.0.0 start /Users/mac/www/chatschool/api
> node ./bin/www

A new connection has been established
```

Se conseguimos obter esta mensagem quer dizer que temos uma conexão em aberto e, se temos a conexão em aberto, isso quer dizer que conseguimos também trabalhar com esta conexão, enviando e recebendo dados.

O próximo passo será enviarmos uma mensagem do usuário, que conectou no webapp, para nosso servidor de API.

Precisaremos atribuir um id para o formulário presente no arquivo **webapp/src/index.html**.

```html
<div class="col-xs-12 type">
    <form>
        <input type="text" id="message" class="form-control" name="message" placeholder="Type your message here">
    </form>
</div>
```

Depois disso nós receberemos o valor digitado, através do seletor jQuery, e enviaremos através do comando **emit** utilizando o socket.io. Para isso altere o arquivo **webapp/src/js**.

```js
var socket = io('//localhost:3000')

$('#message').keypress(function (e) {
    if(e.which == 13){
        var val = $('#message').val()

        socket.emit('message', {
            message: val
        })

        return false
    }
})
```

No código acima estamos pegando o evento de digitação no formulário e quando o evento reconhecer um **enter**, que se trata do número 13, na tabela de códigos, teremos nosso evento de mensagem enviado ao servidor.

Basta fazer o teste de digitar uma mensagem no formulário e precionar **enter**, depois vá até o terminal e confira se recebeu a mensagem digitada. Caso tenha recebido é porque já temos uma conexão de sucesso e já estamos conseguindo receber dados do front-end em nosso servidor.

Ao precionar a tecla *enter* no fomulário deverá receber o seguinte resultado em seu terminal:

```
> api@0.0.0 start /Users/mac/www/chatschool/api
> node ./bin/www

A new connection has been established
{ message: 'Teste' }
{ message: 'Teste 1' }
{ message: 'Teste 2' }
```

Agora estamos prontos para dar continuidade ao nosso desenvolvimento, uma vez que já temos uma conexão entre front-end e servidor.