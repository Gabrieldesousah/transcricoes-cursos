# Configurações com variáveis de ambiente

Continuando o conteúdo do módulo anterior, que mostramos a instalação através do vue-cli e falamos um pouco sobre a estrutura de pastas.

Dentro da pasta **config** existem dois arquivos que são muito interessantes: **dev.env.js** e **prod.env.js**.

Estes dois arquivos são arquivos onde podemos adicionar nossas próprias configurações e como o próprio nome já diz, um arquivo possui configurações de desenvolvimento e outro de produção.

No arquivo package.json existem vários scripts, porém existem dois relacionados às configurações: **dev** e **build**. O dev irá compilar os arquivos de acordo com a configuração, de desenvolvimento, presente no arquivo dev.env.js e o build irá compilar para produção, utilizando o arquivo prod.env.js como base.

Iremos adicionar configurações nestes arquivos, reparem abaixo:

```js
var merge = require('webpack-merge')
var prodEnv = require('./prod.env')

module.exports = merge(prodEnv, {
    NODE_ENV: '"development"',
    SERVER: '"http://localhost:8000"'
})
```

```js
module.exports = {
  NODE_ENV: '"production"',
    SERVER: '"https://api.schoolofnet.com.br"'
}
```

Reparem que, em ambos, adicionamos a propriedade **SERVER**, com endereços fictícios. O importante é que tenhamos estes endereços para realizar o seguinte teste.

Abra o aquivo **main.js** que se encontra dentro da pasta **src**. Veja a alteração:

```js
// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from 'vue'
import App from './App'
import router from './router'

console.log(process.env.SERVER)

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  template: '<App/>',
  components: { App }
})
```

Reparem que não estamos utilizando ponto e vírgula(;), porque a ferramenta **link** que ativamos na instalação segue este tipo de padrão. Então se você adicionar ponto e vírgula ao `console.log(process.env.SERVER)` vai poder ver o erro que ele causa, não permitindo que consigamos acessar o browser. Desta forma você terá que remover para conseguir visualizar.

Você pode estar se questionando: mas eu gosto de utilizar o ponto e vírgula, eu sou acostumado.

Tudo bem, você pode desabilitar o lint e continuar programando do modo que quiser, mas achamos que todo padrão de trabalho é válido e se a ferramenta lhe proporciona este padrão, isso é maravilhoso. Quer dizer que tem um modelo de trabalho a seguir e isso quer dizer que seu código sempre será padronizado.

Depois de ter adicionado o código ao arquivo main.js iremos analisar o console do browser e iremos ver que o valor, que tentamos imprimir, está como **undefined**. Por que isso acontece?

Porque mesmo tendo o recurso **hot module replacement**, que atualiza o browser sempre que uma atualização é feita no arquivos, nós temos que reiniciar o servidor. Caso você tenha feito este procedimento antes, não teve este problemas, mas se o seu servidor estava rodando desde o módulo anterior você teve o mesmo problema. Então rode o comando novamente:

`npm run dev`

E depois olhe novamente o console, para comprovar que está tudo funcionando e que a nossa configuração teve efeito. O browser só não foi recarregado, pelo hot module replacement, porque estes arquivos de configuração não estão sendo assistidos por ele.

![vue_server_console](./images/vue_server_console.png "vue_server_console")

Do mesmo jeito que funcionou para o ambiente de desenvolvimento, funcionará para o ambiente de produção. Caso queira comprovar, basta rodar o comando `npm run build`, que irá criar um diretório chamado **dist**, onde os arquivos estarão compactados e você poderá pesquisar por nosso console log na url que configuramos para o ambiente de produção.

Porém não há necessidade, uma vez que funcionou para o desenvolvimento irá também funcionar para produção.