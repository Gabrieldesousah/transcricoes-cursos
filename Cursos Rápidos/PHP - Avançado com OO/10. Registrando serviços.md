# Registrando serviços

Depois que estamos cientes de como registrar um serviço e como invocá-lo vamos adequar nosso projeto criando os serviços que havíamos criado em nossa classe **Container.php**.

Duplique a pasta **code\_06\_install\_pimple** e renomeie para **code\_07\_recording\_services**.

Veja como ficará o arquivo **/code_07_recording_services/public/index.php**.

```php
require_once "../vendor/autoload.php";

use Pimple\Container;

$container = new Container();

$container['conn'] = function () {
    return new \Source\Conn("mysql:host=localhost;dbname=test_oo","root","");
};

$container['product'] = function ($c) {
    return new \Source\Product($c['conn']);
};

$list = $container['product']->list();

var_dump($list);
```

Vejam que estamos registrando o serviço **conn** e o serviço **product**. Mantivemos a mesma lógica interna e chamamos o serviço acessando o método **list**.

Pronto estamos com nosso projeto refatorado, dentro de um padrão profissional e utilizando o service container do Pimple para gerenciar nossas classes e objetos.

Um detalhe que vale a pena observar é quando precisamos utilizar um serviço dentro de outro. O link da documentação do Pimple mostra, mas vamos alertar aqui.

Quando você passa um parâmetro para a função durante o registro, o Pimple reconhece como sendo um array de todos os serviços registrados então você passa a acesso a todos os serviços internamente. Foi o que aconteceu no serviço **product**. Veja abaixo:

```php
$container['product'] = function ($c) {
    return new \Source\Product($c['conn']);
};
```

Escolhemos passar um parâmetro **$c**, porém você pode passar o nome que preferir, o Pimple reconhecerá qualquer nome que colocar, basta acessar o serviço com a mesma variável passada como parâmetro.

Depois de fazer estas alterações basta rodar o projeto no navegador e ver os produtos sendo listados conforme os projetos anteriores.