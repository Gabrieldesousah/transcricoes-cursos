# Prototype object

O prototype é um dos pilares que constituem a orientação a objetos, porém é um recurso particular do javascript.

Vamos falar sobre este recurso e como podemos tirar proveito do mesmo.

Lembrando do método construtor que mostramos no oitavo módulo, o método initilize precisaria ser executado a cada objeto instanciado para que os dados fossem inclusos na inicialização da classe. Veja exemplo abaixo:

```js
var object1 = new Person('object1', 23, 1.76)
object1.initialize()
var object2 = new Person('object2', 30, 1.63)
object2.initialize()
var object3 = new Person('object3', 27, 1.70)
object3.initialize()
```

Desta forma podemos ver que se fossem muitos objetos nós estaríamos reservando muitos espaços na memória do sistema.

Todo objeto instanciado, ou classe criada, prossui o prototype nativamente. Para verificar basta adicionar o código abaixo, em seu projeto, e abrir o console do navegador.

```js
var object1 = new Person('object1', 23, 1.76)

console.log(object1.__proto__);
console.log(Person.prototype);
```

Percebam que podemos acessar o prototype através do objeto com alias **__proto__** ou a através da classe acessando diratamente o **prototype**. Ambos mostraram o mesmo resultado.

```
// Através do objeto com __proto__
> constructor:ƒ Person(_name, _age, _height)
> __proto__:Object

// Através da classe com prototype
> constructor:ƒ Person(_name, _age, _height)
> __proto__:Object
```

Isso quer dizer que só possuímos um método registrado no prototype, que é o construtor.

Para melhorar esta prática podemos utilizar o prototype, onde podemos incluir métodos a todos os objetos instanciados, independente da quantidade existente, de uma só vez. Para incluir um método a qualquer objeto da classe basta executar o código abaixo:

```js
Person.prototype.initialize = function initialize(){
    console.log('initialize with prototype')
}

var object1 = new Person('Leonan', 23, 1.76)
var object2 = new Person('Leonan', 23, 1.76)
var object3 = new Person('Leonan', 23, 1.76)
```

Depois de adicionar a primeira linha podemos analisar o console novamente e teremos, em todos os objetos, a função **initialize** dentro de cada objeto, ou seja, não será preciso alocar mais memória, uma vez que podemos aproveitar o espaço que já foi reservado ao objeto, pois a função está alocada dentro do mesmo. 

No console teremos o seguinte resultado para os três objetos:

```
{initialize: ƒ, constructor: ƒ}
> initialize:ƒ initialize()
> constructor:ƒ Person(_name, _age, _height)
> __proto__:Object
```

Isso significa que podemos acessar o mesmo método inicialize, do próprio objeto, sem precisar acessar o método initialize da classe. Veja o exemplo:

```js
object1.__proto__.initialize()
object2.__proto__.initialize()
object3.__proto__.initialize()
```

O resultado ao acionarmos o método initialize da classe será o mesmo de acessar via prototype, porém com prototype ganhamos produtividade e performance. Extendemos uma determinada propriedade para qualquer objeto instanciado, aplicando apenas uma vez o método à classe.

Outra vantagem está ao comparar o uso do prototype com métodos estáticos. 

```js
Person.myStaticFunc = function(){
    console.log('Static method');
}

Person.prototype.myProtoFunc = function(){
    console.log('Prototype method');
}

var object1 = new Person('Leonan', 23, 1.76)

object1.myProtoFunc();
object1.myStaticFunc();
```

Vejam que não temos acesso ao método estático através do objeto instanciado, porém o prototype nos permite este acesso.

O prototype, além de todas as vantagens mencionadas, nos permite trabalhar com herança, que é um dos pilares mais importantes da programação orientada a objetos.

Falaremos sobre herança no próximo módulo.