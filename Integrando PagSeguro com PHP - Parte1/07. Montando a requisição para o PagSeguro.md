# Montando a requisição para o PagSeguro

Faremos agora a requisição para o PagSeguro e como no futuro criaremos mais conteúdo, relacionados a formas de pagamento, teremos que criar uma estrutura para isso.

Criaremos um arquivo para testes, em primeiro lugar. Então dentro da pasta **tests** crie um arquivo chamado **MakeRequestTest.php**.

### Conteúdo MakeRequestTest.php

```php
<?php

namespace BrPayments;

class MakeRequestTest extends \PHPUnit\Framework\TestCase
{
    public function testPagSeguroRequest()
    {
        $access = [
            'email'=>'erik.figueiredo@gmail.com',
            'token'=>'E7EF160DE74646CE80AB18EDDA257F1B',
            'currency'=>'BRL',
            'reference'=>'REF1234'
        ];

        $pag_seguro = new Payments\PagSeguro($access);

        //name, areacode, phone, email
        $pag_seguro->customer('Jose Comprador', 11, 99999999, 'c75336791632449484854@sandbox.pagseguro.com.br');

        //type, street, number, complement, district, postal code, city, state, country
        $pag_seguro->shipping(
            1,
            'Av. PagSeguro',
            99,
            '99o andar',
            'Jardim Internet',
            99999999,
            'Cidade Exemplo',
            'SP',
            'ATA'
        );

        //id, description, amount, quantity, wheight(optional)
        $pag_seguro->addProduct(1, 'Curso de PHP', 19.99, 20);
        $pag_seguro->addProduct(2, 'Livro de Laravel', 15, 31, 1.5);
    }
}
?>
```

Em primeiro lugar gostaríamos de falar que este teste não é um teste unitário, ele se caracteriza mais por ser um teste de integração. Mas o mais importante é a função que esta classe terá.

> Primeiro passo

Atribuímos os dados do **vendedor** do Sandbox para variável **$access**.

> Segundo passo

Criamos o objeto $pag_seguro, intanciando a classe PagSeguro e passando os dados anteriores para parâmetro.

> Terceiro passo

Informamos os dados do **comprador**, do Sanbox, para o método **customer**.

***

O restante já estava tudo criado e não modificaremos mais nada nesta classe. A única diferença é que estamos utilizando uma variável local, chamada $page_seguro, ao invés de utilizar a variável de instância, que estávamos utilizando anteriormente($this->pag\_seguro).

> Quarto passo

Criamos todo código necessário para fazermos nossa requisição real e direta com o Sanbox. Veja o código abaixo:

```php
<?php
//requisição
$pag_seguro_request = new Requests\PagSeguro();

$response = (new MakeRequest())->post($pag_seguro, true);

$xml = new \SimpleXMLElement((string)$response);
$url = $pag_seguro_request->getUrlFinal($xml->code, true);

$this->assertTrue(is_string($url));
?>
```

Primeiro nós criamos um objeto, chamado **$pag\_seguro\_request**, onde instanciamos a classe PagSeguro que está dentro do diretório **Request**. Nós ainda não a classe e o diretório, mas já iremos implementar.

Logo depois criamos um objeto, chamado **$response** onde instanciamos a classe MakeRequest e acessamos o método **post**, passando a variável $pag_seguro e true, como parâmetros. Este segundo parâmetro, do tipo boolean, informa se vamos utilizar o Sandbox ou não.

O próximo passo foi criar um outro objeto que receberá um XML. Então utilizamos a função do PHP **SimpleXMLElement**, passando o response que foi atribuido anteriormente através da classe fornecido pelo **guzzle**, biblioteca que instalamos, no início do projeto, com o Composer.

E para o teste final nós criamos uma variável, chamada **url**, onde acessamos o método **getUrlFinal** passando o **$xml->code**, atribuído anteriormente, e depois o booleano para indicar se vamos, ou não, utilizar o Sanbox.

O método getUrlFinal ainda não foi criado, mas ele retornará a url para que possamos testar e nosso teste é saber se está retornando um string realmente.

# Criando classe src/Requests/PagSeguro.php

Criaremos um arquivo, chamado **PagSeguro.php**, dentro do seguinte caminho de pastas: **src/Requests**.

### Contéudo da classe

```php
<?php
namespace BrPayments\Requests;
use BrPayments\Payments\PagSeguro as Order;
class PagSeguro
{
    // URL pagamento sem Sandbox
    const URL = 'https://pagseguro.uol.com.br/v2/checkout/payment.html';
    const URL_CHECKOUT = 'https://ws.pagseguro.uol.com.br/v2/checkout';
    // Método
    const METHOD = 'POST';
    // URL pagamento com Sandbox
    const URL_SANDBOX = 'https://sandbox.pagseguro.uol.com.br/v2/checkout/payment.html';
    const URL_CHECKOUT_SANDBOX = 'https://ws.sandbox.pagseguro.uol.com.br/v2/checkout';

    public function getUrlCheckout(Order $order, bool $sandbox = null)
    {
        if ($sandbox) {
            return PagSeguro::URL_CHECKOUT_SANDBOX . '?' . (string)$order;
        }
        return PagSeguro::URL_CHECKOUT . '?' . (string)$order;
    }

    public function getMethod()
    {
        return PagSeguro::METHOD;
    }

    public function getUrlFinal($code, bool $sandbox = null)
    {
        if ($sandbox) {
            return PagSeguro::URL_SANDBOX . '?code=' . (string)$code;
        }
        return PagSeguro::URL . '?code=' . (string)$code;
    }
}
?>
```

Reparem que o primeiro processo foi a atribuição de URLs, você as pode encontrar na API do Pag Seguro facilmente. Vocês podem perceber também que são diferentes. O Pag Seguro fornece URL para pagamentos oficiais e URLs para pagamentos via Sandbox.

Depois atribuímos também o tipo de requisição, ou método, que definimos como **POST**.

Nós já atribuímos constantes com as URLs que precisamos, porém estas URLs precisam de mais parâmetros e estes serão adicionados pales classes seguintes. Estes dados virão de nossas classes e métodos.

Criamos o método **getMethod** que é muito simples e apenas retorna o método que será utilizado na requisição.

Depois temos uma classe para formar a URL, e os parâmetros, para checkout e também outro método para pegar a url final. Esta última foi o método que utilizamos para realizar nosso teste.

Veja que, em ambos métodos, nós temos o parâmetro booleano para informar se utilizaremos, ou não, o Sandbox.

Agora precisamos criar o **MakeRequest**, mas como o conteúdo está ficando muito grande, faremos no próximo módulo.